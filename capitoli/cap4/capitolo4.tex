\chapter{Estensione del modello di simulazione EIB}\label{cap:capitolo4}

In questo capitolo viene sviluppata la prima fase del lavoro di tesi. Questa consiste nell'integrazione di Cellsim tramite un modello di simulazione dettagliato e parametrico per l'infrastruttura di comunicazione EIB adottata dal Cell Broadband Engine.
Il capitolo è organizzato come segue: nel primo paragrafo viene descritto in maggior dettaglio l'element interconnect bus, in modo tale da evidenziarne le caratteristiche architetturali (configurazione topologica, gestione delle comunicazioni end-to-end, ecc\ldots); nel secondo paragrafo viene descritta la soluzione adottata da Cellsim per l'interconnessione dei moduli del simulatore, il k-bus. Questo rappresenta anche l'infrastruttura di base usata per l'integrazione del modello di simulazione di EIB, in quanto fornisce le funzionalità cardine come ad esempio i processi per la gestione del protocollo di comunicazione e le risorse di memorizzazione in ingresso (buffer); nel terzo paragrafo, infine, viene presentata la soluzione adottata (con rispettivo codice di implementazione UNISIM) per ogni singola funzionalità introdotta.
%In questo capitolo viene sviluppata la prima parte del lavoro di tesi. Questa consiste nell'estensione del modello di simulazione fornito da Cellsim per l'infrastruttura di comunicazione del processore Cell. Attualmente, come visto anche nel Capitolo~\ref{cap:capitolo2}, Cellsim fa uso di un sistema di connessione significativamente differente da EIB, il k-bus.\\ 
%Il nostro obiettivo è quello di integrare il simulatore tramite un modello di rete di comunicazione completamente parametrico che, a differenza del k-bus, ricalchi fedelmente il progetto di EIB e permetta di ottenere risultati più vicini a quelli reali. A tale scopo il primo paragrafo del presente capitolo è dedicato alla descrizione approfondita delle caratteristiche di EIB, in modo da estrarne le specifiche progettuali da integrare sul modello di simulazione. 

\section{Analisi dell'infrastruttura di comunicazione EIB}

%Con l'aumento dei calcolatori multicore, il progetto delle reti di interconnessione on-chip ha assunto un'importanza crescente nell'architettura del sistema. Attualmente l'attività di ricerca è mirata alla progettazione di network on chip efficenti; questo perché oramai si è consapevoli del fatto che i fili sono il fattore dominante nella determinazione delle performance di un sistema, della dissipazione di potenza, dell'affidabilità, dei costi e di altre importanti caratteristiche. Le architetture di network on chip proposte non sono più grosse strutture a bus condiviso, ma piuttosto reti di connessione punto-punto o commutate (switched) che assumono la forma di bus gerarchici, ring, mesh, crossbar e altre topologie irregolari. Tali architetture possono essere utilizzate per differenti scopi a cominciare dal trasferimento di istruzioni, operandi e blocchi di cache per finire con l'implementazione dei meccanismi di cache coherency, informazioni di stato e controllo. \\
EIB è l'infrastruttura di comunicazione utilizzata dal Cell Broadband Engine per il trasporto di istruzioni e lo scambio di dati tra i core on-chip. Ciascuno di questi è interfacciato a EIB tramite un Bus Interface Unit (BIU), il quale è a sua volta collegato alle due BIU vicine. La versione attuale adotta una topologia a quattro ring (due per ogni direzione), ciascuno dei quali ha un'ampiezza di 16-byte per il trasporto dati, un \emph{command bus} condiviso e un \emph{data arbiter} connesso direttamente a tutti e dodici gli elementi del sistema.\\
Il \emph{command bus}, mostrato al centro nella Figura~\ref{fig:command-bus}, ordina i comandi, setta le transazioni end-to-end e si occupa della gestione della cache coherency. 
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.6]{figure/command-bus}
	\caption{Diagramma di EIB - al centro il \emph{Command Bus} e i quattro data ring}
	\label{fig:command-bus}
\end{figure}
Esso è costituito da cinque \emph{address concentrator} (AC) distribuiti, organizzati in una struttura ad albero in modo da permettere a più comandi di viaggiare contemporaneamente attraverso la rete. Gli \emph{address concentrator} gestiscono la rilevazione e la prevenzione delle collisioni, inoltre forniscono un accesso equo alla risorsa. E' possibile propagare fino a tre comandi verso l'AC0, il quale provvede alla riflessione degli stessi verso tutti i core del sistema, il tutto a una velocità di un comando per ciclo. Gli \emph{address concentrator} e il \emph{command bus} sono completamente pipelined. Quest ultimo opera a una frequenza pari alla metà di quella dei core.\\ 
Ciascun ring è in grado di supportare fino a un massimo di tre trasferimenti concorrenti non sovvrapposti, permettendo così alla rete di avere, in totale, fino a dodici trasferimenti simultanei.\\
Il \emph{data arbiter}, al centro della Figura~\ref{fig:data-arbiter}, è implementato mediante una struttura a stella. Esso controlla l'accesso ai ring di EIB da parte di ciascuna transazione.\\ 
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.6]{figure/data-arbiter}
	\caption{Diagramma di EIB - al centro il \emph{Data Arbiter} e i quattro data ring}
	\label{fig:data-arbiter}
\end{figure}
Nella descrizione fornita è possibile identificare un primo gruppo di specifiche progettuali:
\begin{itemize}
	\item[$\circ$] configurazione topologica adottata;
	\item[$\circ$] dimensione del canale dati su ciascun ring;
	\item[$\circ$] meccanismi per la gestione della cache coherency, l'instaurazione delle comunicazioni end-to-end e l'ordinamento dei comandi;
	\item[$\circ$] numero massimo di transazioni supportabili contemporaneamente su ogni ring.
\end{itemize}
Tali specifiche devono essere implementate all'interno del simulatore utilizzando la sintassi UNISIM. Poiché molte delle funzionalità di base, come ad esempio la sincronizzazione con gli altri moduli del sistema e la gestione della cache coherency, vengono attualmente fornite anche dal k-bus, questo viene adottato come infrastruttura di base per l'integrazione. 

\section{Infrastruttura di comunicazione k-bus}
Il k-bus fornisce ai moduli del simulatore uno strumento di comunicazione coerente e parametrico in termini di numero di unità da interconnettere, dimensione dei buffer presenti nelle porte di ingresso, banda disponibile, numero di ring e dimensione del pacchetto. Tali parametri, sono contenuti nella sezione \texttt{EIB} del file \texttt{default\_configuration\_parameters.h}.
\begin{lstlisting}[caption=Sezione contenente i parametri di configurazione del bus all'interno del file \texttt{dafault\_configuration\_parameters.h},label=lst:listato20]
/*----------EIB---------------*/
const int BUS_BW = 8;
const int PACKET_SIZE = 128;
const int MAX_OUTST_TR = 4;
const int NUM_BUSES = 4;
\end{lstlisting}
Il significato di ogniuno di questi è riportato di seguito:
\begin{itemize}
	\item[$\circ$] \texttt{BUS\_BW}: rappresenta la banda disponibile per il trasferimento dei dati (di default è pari a 8-byte/ciclo). Tale parametro viene utilizzato, insieme a \texttt{PACKET\_SIZE} e al campo \texttt{\_size} dei memory access, per il calcolo del numero dei cicli che il pacchetto deve attendere in ingresso al bus, prima di essere inviato alla porta di uscita corrispondente (latenza del pacchetto all'interno del bus);
	\item[$\circ$] \texttt{PACKET\_SIZE}: rappresenta l'ampiezza dei bus dati, ovvero di ciascun ring (di default assume il valore 128-byte);
	\item[$\circ$] \texttt{NUM\_BUSES}: rappresenta il numero di ring (di default pari a 4);
	\item[$\circ$] \texttt{MAX\_OUTST\_TR}: rappresenta il numero di transazioni simultanee supportato; tale valore viene utilizzato per fissare la dimensione dei buffer di input, relativamente alle transazioni di tipo \texttt{store}. 
\end{itemize}

Nelle sezioni che seguono viene illustrato il codice UNISIM\footnote{Tutto il codice di seguito descritto è contenuto all'interno del file \texttt{./cellsim-0.9\_original/src/modules/processor/EIB.sim}} corrispondente a ogni funzionalità offerta da k-bus a cominciare dal protocollo di comunicazione, adottato da tutti i moduli del simulatore (Capitolo~\ref{cap:capitolo2}), per arrivare alla gestione delle transazioni end-to-end.

\subsection{Protocollo di comunicazione}
Il protocollo di comunicazione impiegato in Cellsim è stato già descritto nel Capitolo~\ref{cap:capitolo2}. Questo fa uso dei processi \texttt{start\_of\_cycle(), on\_data(), on\_accept(), end\_of\_cycle()} per ottenere la sincronizzazione tra i moduli del simulatore. Analizziamo separatamente ogniuno di questi processi.

\subsubsection{start\_of\_cycle()}
\texttt{start\_of\_cycle()} è sensibile ai fronti positivi del clock ed è perciò il primo processo ad essere attivato all'inizio di ogni nuovo ciclo.
\begin{lstlisting}[caption=Codice del processo \texttt{start\_of\_cycle()},label=lst:listato21]
void start_of_cycle()
{	for (int i= 0; i < PORT_COUNT; i++)
	{
		if (_outputBuffers[i])
		{ 	out_port[i].data= _outputBuffers[i];
		}
		else
		{	out_port[i].data.nothing();
		}
	}
	_nextInputData= 0;
	_nextOutputAccept= 0;
	_sthOcc = false;
}
\end{lstlisting}
\begin{itemize}
	\item[$\circ$] \texttt{\_outputBuffers} è il buffer di uscita. Ve ne è uno per ogni porta del bus e può contenere un solo puntatore di tipo MemoryAccess per volta. Nel codice su riportato, se in \texttt{\_outputBuffers[i]} non sono presenti memory access, l'uscita viene settata al valore \texttt{nothing}, in accordo con le specifiche UNISIM.
	\item[$\circ$] \texttt{PORT\_COUNT}, all'interno del ciclo \texttt{for}, indica che il controllo deve essere eseguito per tutte le porte del bus (di default è pari a 10). 
\end{itemize}

\subsubsection{on\_data()}
Viene eseguito dopo \texttt{start\_of\_cycle()} ed è sensibile al segnale di ingresso \texttt{data}; una volta attivato, esegue le seguenti operazioni:
\begin{itemize}
	\item[$\circ$] controlla su tutte le porte di ingresso lo stato del segnale \texttt{data};
	\item[$\circ$] se lo stato di tale segnale è \texttt{known} e la funzione \texttt{something()} restituisce \texttt{vero}, significa che un modulo ha mandato in ingresso un memory access valido;
	\item[$\circ$] a questo punto, stabilisce il tipo di richiesta (\texttt{store} o \texttt{load}) e controlla la disponibilità del buffer d'ingresso; se l'esito di tale controllo è positivo, invia al modulo mittente un uno logico sul segnale \texttt{accept}, in caso contrario manda zero. 
\end{itemize}
\begin{lstlisting}[caption=Codice del processo \texttt{on\_data()},label=lst:listato22]
void on_data()
{	// Wait to known all input data
	while(_nextInputData < PORT_COUNT && in_port[_nextInputData].data.known())
	{	if(in_port[_nextInputData].data.something())
		{	if(((MemoryAccess_bus)in_port[_nextInputData].data)->is_load() ||
			  ((MemoryAccess_bus)in_port[_nextInputData].data)->is_atomic_load())
			{	in_port[_nextInputData].accept=!_inputLdBuffers[_nextInputData];
			}
			else
			{	in_port[_nextInputData].accept=
									!_inputStBuffers[_nextInputData]->is_full();
			}
		}
		else
		{	in_port[_nextInputData].accept = false;
		}
		_nextInputData++;
	}
}
\end{lstlisting}
\begin{itemize}
	\item[$\circ$] \texttt{\_nextInputData} è l'identificativo della porta di ingresso in esame;
	\item[$\circ$] \texttt{in\_port} è il nome della porta di ingresso;
	\item[$\circ$] \texttt{\_inputLdBuffers} è il buffer usato per memorizzare le richieste di tipo \texttt{load} e può contenere un solo memory access per volta;
	\item[$\circ$] \texttt{\_inputStBuffers} è il buffer utilizzato per memorizzare le richieste di tipo \texttt{store}; questo è definito come una lista di elementi MemoryAccess (di dimensione pari a \texttt{MAX\_OUTST\_TR}), all'interno del file \texttt{MemoryAccessList.h} nel percorso \texttt{./cellsim-0.9/src/library/\-simulator/}. Tale classe definisce tutti i metodi necessari alla gestione della risorsa, come ad esempio il metodo booleano \texttt{is\_full()}, utilizzato nel Listato~\ref{lst:listato22} per verificare lo stato del buffer. 
\end{itemize}

\subsubsection{on\_accept()}
Il processo è sensibile al segnale \texttt{accept} e si occupa di controllare, su tutte le porte di uscita del bus, se è stato ricevuto qualche segnale di \texttt{accept} alto; in caso affermativo genera l'\texttt{enable} per l'uscita corrispondente.
\begin{lstlisting}[caption=Codice del processo \texttt{on\_accept()},label=lst:listato23]
void on_accept()
{	// Wait to known all output data
	while(_nextOutputAccept < PORT_COUNT && 
		  out_port[_nextOutputAccept].accept.known())
	{	out_port[_nextOutputAccept].enable= out_port[_nextOutputAccept].accept;
		_nextOutputAccept++;
	}
}
\end{lstlisting}
Nel Listato~\ref{lst:listato23} \texttt{\_nextOutputAccept} ha lo stesso significato di \texttt{\_nextInputData}, ma stavolta è riferito al segnale di \texttt{accept} della porta di uscita.

\subsubsection{end\_of\_cycle()}
Al termine di ogni ciclo, i segnali in ingresso sono stabili e pronti per l'elaborazione, \texttt{end\_of\_cycle()} definisce le operazioni che devono essere effettuate sui dati.
\begin{lstlisting}[caption=Codice del processo \texttt{end\_of\_cycle()},label=lst:listato24]
void end_of_cycle()
{
	output_consumes();
	read_input();
	decr_latency();
	route();
}
\end{lstlisting}
\begin{itemize}
	\item[$\circ$] \texttt{output\_consumes()} si occupa di svuotare i buffer di uscita per i quali è stato ricevuto un valore alto del segnale \texttt{accept}. 
	\item[$\circ$] \texttt{read\_input()} memorizza, nel buffer corretto (di load o di store), i memory access in ingresso, per i quali è stato ricevuto un segnale di \texttt{enable} alto. 
	\item[$\circ$] \texttt{decr\_latency()} a ogni ciclo di clock riduce di una unità la latenza dei memory access che sono memorizzati sugli store buffer di ingresso; quando tale valore è pari a zero, il memory access può essere spostato da \texttt{route()} nel buffer corrispondente all'uscita desiderata.\\ 
	\item[$\circ$] \texttt{route()} si occupa della gestione della coerenza e del trasferimento end-to-end dei memory access.
\end{itemize}

\subsection{Gestione delle transazioni: la funzione \texttt{route()}}

Come detto, il trasferimento dei dati all'interno del bus viene eseguito tramite \texttt{route()}; questa si occupa anche della gestione della coerenza. A tale scopo il simulatore mette e disposizione due transazioni aggiuntive \texttt{atomic\_load} e \texttt{atomic\_store}.\\  
L'accesso coerente avviene nel seguente modo:
\begin{enumerate}
	\item i moduli inviano una \texttt{atomic\_load} per richiedere l'accesso coerente a una locazione di memoria;
	\item il bus tiene traccia delle richieste associando alle porte di ingresso l'indirizzo di tale locazione di memoria;
	\item se un modulo che non ha riservato l'accesso invia una \texttt{atomic\_store} a quell'indirizzo, la richiesta viene rifiutata;
	\item se un modulo invia una \texttt{store} a quell'indirizzo, la locazione viene invalidata e tutti i core che ne hanno una copia locale ricevono una notifica.
\end{enumerate}
\begin{lstlisting}[caption=Codice relativo alla gestione delle atomic\_load nel processo \texttt{route()},label=lst:listato25]
void route(int inportn)
{
	...

	if(_inputLdBuffers[inportn])
	{
		int outportn= get_port_number(_inputLdBuffers[inportn]);
		if (!_outputBuffers[outportn])
		{
			MemoryAccess* access = _inputLdBuffers[inportn];
			if(access->is_atomic_load())
			{
				reserve_address(access->get_target(), inportn);
			}
			...
		}
		...
	}
	...
}
\end{lstlisting}
\begin{itemize}
	\item[$\circ$] \texttt{reserve\_address(\ldots)} riserva alla porta identificata tramite \texttt{inportn} l'indirizzo specificato dal memory access contenuto in \texttt{\_inputLdBuffers[inportn]}.
	\item[$\circ$] \texttt{get\_target()} restituisce l'indirizzo contenuto nel campo \texttt{\_target} del memory access.
\end{itemize}
\begin{lstlisting}[caption=Codice relativo alla gestione delle atomic\_store all'interno \texttt{route()},label=lst:listato26]
void route(int inportn)
{
	...
	//Coherent access
	if((inportn > PROCESSOR_COUNT) && (outportn == 0))
	{	if( (!_outputBuffers[outportn] && (!_outputBuffers[1])) &&
			(!access->is_atomic_store() || (access->is_atomic_store() && 
											!_outputBuffers[inportn])) )
		{	if(access->is_atomic_store())
			{
				MemoryAccess* response = access;
				if(check_reservation(access->get_target(), inportn))
				{
					access = MemoryAccess::create_copy(response);
					response->reverse();
					response->set_successful(true);
					_outputBuffers[inportn] = response;
					_outputBuffers[outportn]= access;
					sendInvalidateToCaches(access);
					invalidate_reservations(access->get_target());
				}
				else
				{
					response->reverse();
					response->set_successful(false);
					_outputBuffers[inportn] = response;
				}
			}
			else
			{
				_outputBuffers[outportn]= access;
				sendInvalidateToCaches(access);
				invalidate_reservations(access->get_target());
			}
			...
		}
		...
	}
	...
}
\end{lstlisting}
Nel listato è riportato il codice relativo all'accesso coerente da parte di un accelerator (SPE), denotato dalla condizione \texttt{inportn $>$ PROCESSOR\_COUNT} all'interno del primo \texttt{if}.
\begin{itemize}
	\item[$\circ$] il metodo \texttt{is\_atomic\_store()} della classe MemoryAccess restituisce \texttt{vero} se il memory access è di tipo \texttt{atomic\_store}, falso in caso cotrario. 
	\item[$\circ$] il metodo \texttt{check\_reservation(\ldots)} controlla se la porta \texttt{inport} ha precedentemente riservato l'accesso tramite una \texttt{atomic\_load}.
	\item[$\circ$] il metodo \texttt{reverse()} della classe MemoryAccess scambia, all'interno del memory access, gli indirizzi di \texttt{\_target} e \texttt{\_source}.
	\item[$\circ$] il metodo \texttt{set\_successful(\ldots)} viene usato per segnalare al mittente che la transazione ha avuto successo.
	\item[$\circ$] il metodo \texttt{invalidate\_reservation(\ldots)} viene usato per segnalare agli altri moduli che avevano una reservation sulla locazione che questa è cambiata.
	\item[$\circ$] \texttt{sendInvalidateToCaches(\ldots)} segnala alla cache della PPE che la locazione non è più valida; a tale scopo viene eseguito, all'interno del primo \texttt{if}, un controllo preliminare per verificare lo stato del buffer di uscita corrispondete alla porta della cache.
\end{itemize}

\section{Integrazione delle specifiche architetturali di EIB all'interno del k-bus}

Iniziamo col considerare la specifica riguardante la topologia. Per implementare la configurazione a ring adottata da EIB sono state introdotte le variabili globali:
\begin{lstlisting}[caption=Variabili topologiche,label=lst:listato27]
MemoryAccess* access_table[RING_COUNT][MAX_COEXISTING_TRANSACTIONS];
bool direction_table[RING_COUNT];
\end{lstlisting}
\begin{itemize}
	\item[$\circ$] \texttt{RING\_COUNT} è il parametro che definisce il numero di ring;
	\item[$\circ$] \texttt{MAX\_COEXISTING\_TRANSACTIONS} definisce il numero transazioni che possono coesistere su ciascun ring;
	\item[$\circ$] \texttt{access\_table} è una matrice di puntatori a memory access avente dimensione \texttt{RING\_COUNT $\times$ MAX\_COEXISTING\_TRANSACTIONS}. I memory access in ingresso vengono spostati dai rispettivi buffer all'interno di questa tabella in accordo con le politiche di arbitraggio adottate;
	\item[$\circ$] \texttt{direction\_table} è un vettore di bool di dimensione pari a \texttt{RING\_COUNT}. Al suo interno è specificata la direzione di percorrenza di ciascun ring: \texttt{CLOCKWISE} (oraria) o \texttt{COUNTERCLOCLWISE} (antioraria). In questo modo se un modulo deve comunicare con i suoi vicini, percorrerà la stessa distanza, piuttosto che fare un giro completo in uno dei due casi.
\end{itemize}

\subsection{Gestione delle transazioni}
L'accesso alla risorsa \texttt{access\_table} da parte dei moduli del simulatore deve essere regolamentato, in modo da prendere in considerazione tutte quelle situazioni che, nel sistema reale, possono causare il rifiuto della richiesta di trasferimento. Infatti, mentre dal punto di software è possibile inserire in \texttt{access\_table} tanti memory access quante sono le sue locazioni disponibili, dal punto di vista hardware si possono creare delle situazioni, all'interno dell'element interconnect bus, che limitano il numero di richieste realmente soddisfabili. Quando un modulo richiede l'accesso all'infrastruttura di comunicazione, vi sono diverse ragioni per le quali quest'ultima può rifiutare:
\begin{itemize}
	\item[$\circ$] \textbf{overlapping}. Si consideri la Figura~\ref{fig:overlapping}, nella quale è presente solamente un ring antiorario. In figura, la SPE0 sta parlando con la PPE (linea evidenziata in verde), contemporaneamente la SPE1 tenta di comunicare con la memoria principale (MEM), linea evidenziata in blu. In questo caso, nonostante sia possibile supportate più transazioni allo stesso tempo, la SPE1 non può instaurare una connessione con la memoria, poiché i due percorsi si sovrappongono. Nell'implementazione di EIB bisogna tenere conto di tale evenienza e fare in modo che venga selezionato, per la seconda transazione, il ring successivo, se disponibile.
\begin{figure}[!htbp]
	\centering 
	\includegraphics[scale = 0.8]{figure/overlapping}
	\caption{Esempio di sovrapposizione di due percorsi sul ring}
	\label{fig:overlapping}
\end{figure}
	\item[$\circ$] \textbf{overlapping target}. Si ha overlapping target quando in ingresso al bus sono presenti due memory access diversi che hanno lo stesso campo \texttt{\_target} (Figura~\ref{fig:overlapping-target}). Se i due memory access vengono elaborati nello stesso ciclo, la contesa viene risolta dando la priorità a quello proveniente dalla porta di ingresso con identificativo più basso. In caso contrario, quello che arriva per ultimo attende nell'input buffer il suo turno.  
\begin{figure}[!htbp]
	\centering 
	\includegraphics[scale = 0.8]{figure/overlapping-target}
	\caption{Esempio di conflitto tra due transazioni che sono dirette verso lo stesso target}
	\label{fig:overlapping-target}
\end{figure}
	\item[$\circ$] \textbf{not available transaction}. Se non sono disponibili locazioni all'interno di \texttt{access\_table}, il memory access attende, nel buffer di ingresso, che una risorsa si liberi.
	\item[$\circ$] \textbf{lost arbitration}. Come appena accennato, nel caso in cui due memory access chiedano contemporaneamente l'accesso al mezzo di comunicazione, è possibile risolvere la contesa utilizzando una politica di arbitraggio a priorità fissa che privilegi la transazione proveniente dalla porta con identificativo più basso all'interno del bus. 
\end{itemize} 
Finora sono state descritte le cause che portano a una perdita della risorsa da parte di un memory access presentato in ingresso al bus. Viene ora descritto, con maggiore dettaglio, l'algoritmo per la gestione delle transazioni adottato nel modello di simulazione di EIB, il quale cerca di identificare le situazioni sopra citate e di risolvere la contesa del mezzo in modo equo, tramite una politica di arbitraggio a priorità fissa. \\

L'algoritmo che implementa la gestione delle transazioni, all'interno del simulatore, fa uso di diverse funzioni, ciascuna delle quali si occupa di un compito ben preciso:
\begin{itemize}
	\item[$\circ$] \textbf{arbitrate()}: per ogni memory access presente in ingresso, esegue un controllo in modo da verificare la presenza di una transazione disponibile all'interno di \texttt{access\_table}; inoltre, valuta anche, tramite un'analisi dei percorsi richiesti e di quelli in uso, l'occorrenza di overlapping e overlapping target. Se per questi ultimi due non vi è riscontro positivo, assegna alla porta corrispondente al memory access analizzato un flag, tramite la variabile booleana \texttt{enable\_arbitration[port\_number]}, che ne donota la canditura all'utilizzo del mezzo di comunicazione. Il procedimento descritto viene eseguito, all'interno del ciclo di clock, per tutti i memory access in ingresso. Tra quelli contrassegnati da \texttt{enable\_arbitration[port\_number]}, viene selezionato quello a più alta priorità.
	\item[$\circ$] \textbf{required\_path\_generation(\ldots)}: prende in ingresso un memory access e per questo calcola gli identificativi di sorgente e destinatario, che memorizza rispettivamente in \texttt{required\_source\_id} e \texttt{required\_destination\_id}.
	\item[$\circ$] \textbf{compute\_path(\ldots, \ldots)}: viene richiamata da \texttt{arbitrate()} per il calcolo del percorso richiesto dal memory access. Tale percorso viene ottenuto a partire dagli identificativi di sorgente e destinatario e memorizzato in una variabile monodimensionale di nome \texttt{clockwise\_path/counterclockwise\_path} a seconda del tipo di ring selezionato: orario o antiorario, rispettivamente. 
	\item[$\circ$] \textbf{path\_analyzer()}: utilizza \texttt{clockwise\_path/counterclockwise\_path} per verificare la presenza di overlapping o overlapping target.
	\item[$\circ$] \textbf{analyze\_input()}: tutti i memory access che sono stati etichettati dalla funzione \texttt{arbitrate()}, tramite \texttt{enable\_arbitration[port\_number]}, vengono inseriti nell'\texttt{access\_table}. Per ogniuno di questi vengono inoltre riempite anche le tabelle \texttt{transaction\_table}, contenente il path utilizzato, \texttt{latency\_table}, rappresentante il numero di cicli di latenza all'interno del ring e \texttt{length\_path} che specifica la lunghezza del path; questa viene usata per liberare il buffer di ingresso e lasciare spazio a un'eventuale nuova richiesta; quando la latenza del memory access uguaglia la distanza tra source e destination, significa che gli ultimi dati del pacchetto stanno lasciando il source. 
\end{itemize} 

\subsection{La funzione arbitrate()}
\begin{lstlisting}[caption=Funzione \texttt{arbitrate()} per l'implementazione dell'arbitraggio,label=lst:listato28]
int arbitrate()
{
	...
	if((!_inputStBuffers[i]->is_empty() && arbitrate_flag_st[i]) || 
	(_inputLdBuffers[i] != NULL && arbitrate_flag_ld[i]) )
	{
		MemoryAccess* access;
		if(!_inputStBuffers[i]->is_empty())
		{
			MemoryAccessList::iterator it = _inputStBuffers[i]->begin();
			access = *it;
		}
		else
		{
			if(_inputLdBuffers[i])
				access = _inputLdBuffers[i];
		}
	}	
	required_path_generation(access);
	compute_paths(i, required_destination_ID);
	path_analyzer();
	if(!overlapping && transaction_available && !overlapping_target)
	{
		enable_arbitration[i] = true;
	}
    ...  
	for(int i=0; i<PORT_COUNT;i++)
	{
		if(enable_arbitration[i])
		{
			if (memory_access_selected==false)
			{
				memory_access_selected=true;
				selected_memory_access=i;
			}
			else
			{
				if (my_priority[i]>my_priority[selected_memory_access])
				{
					for(int j=0; j<PORT_COUNT;j++)
					{
						if (i!=j)
						{
							if (enable_arbitration[j])
							{
								if (my_priority[i]>my_priority[j])
								{
									selected_memory_access=i;
								}
							}
						}
					}
				}
			}
		}
	}
}                                                                         
\end{lstlisting}
\begin{itemize}
	\item[$\circ$] \texttt{arbitrate\_flag\_st[i]} e \texttt{arbitrate\_flag\_ld[i]} sono due flag utilizzati per segnalare all'arbitro che i memory access corrispondenti alla porta i sono già stati arbitrati e non devono quindi essere ripresi in considerazione. Infatti, quando i memory access ottengono la risorsa e sono inseriti nell'\texttt{access\_table}, non vengono rimossi dai buffer di ingresso. Questo perché così facendo, il modulo connesso a tale porta non può inviare nuove richieste prima che il bus abbia terminato la trasmissione del dato precedente. Il comportamento descritto è coerente con l'implementazione hardware, poiché è logico che un IP core ha una banda di trasferimento finita, mentre nel simulatore il messaggio viene mandato in ingresso a EIB in un solo ciclo (indipendentemente dalla sua dimensione). A tale scopo, questi flag vengono settati a falso quando le richieste corrispondenti sono state inserite nell'\texttt{access\_table} e vengono risettati a vero quando le latenze sono pari alla lunghezza del percorso.
	\item[$\circ$] \texttt{my\_priority[i]} contiene la priorità dell'ingresso; questa è data da \texttt{PORT\_COUNT} - i. Se è presente un altro memory access su un ingresso j (dove j $<$ i), la risorsa viene assegnata a quest ultimo.
	\item[$\circ$] \texttt{MemoryAccessList::iterator it = \_inputStBuffers[i]$->$begin()} assegna a \texttt{it} il puntatore al primo elemento dell'\texttt{\_inputStBuffers[i]}, che nel caso specifico dell'implementazione è anche l'unico, dato che il numero di transazioni sumultanee viene modellato dal parametro \texttt{MAX\_COEXISTING}\-\texttt{\_TRANSACTION} e non più da \texttt{MAX\_OUTST\_TR}.
\end{itemize} 

\subsection{La funzione required\_path\_generation(\ldots)}
\begin{table}[H]
\begin{lstlisting}[caption=Funzione \texttt{required\_path\_generation(\ldots)} per la generazione del path, label=lst:listato29]
void required_path_generation(MemoryAccess* access)
{
	...
	required_source=access->get_source();
	required_destination=access->get_target();
	required_source_ID=compute_port(required_source);
	required_destination_ID=compute_port(required_destination);
}
\end{lstlisting}
\end{table}
\texttt{compute\_port(\ldots)} viene usato per calcolare la porta di uscita corrispondente al campo \texttt{\_target} del memory access. Tale assegnazione viene fatta in accordo con la Tabella~\ref{tab:routing-table}.

\subsection{La funzione compute\_path(\ldots,\ldots)}
\begin{lstlisting}[caption=Funzione \texttt{compute\_path(\ldots,\ldots)}, label=lst:listato29]
void compute_path(int required_source_ID, required_destination_ID)
{
	//compute clockwise
	clockwise_path=0;
	clockwise_path_length=0;
	if (required_source_ID>required_destination_ID)
	{
		for (int i=0;i<PORT_COUNT;i++)
		{
			if ((i>=required_source_ID)||(i<=required_destination_ID))
			{
				clockwise_path=(clockwise_path+(0x00000001<<i));
				clockwise_path_length++;
			}
		}
	}
	else
	{
		for (int i=0;i<PORT_COUNT;i++)
		{
			if ((i>=required_source_ID)&&(i<=required_destination_ID))
			{
				clockwise_path=(clockwise_path+(0x00000001<<i));
				clockwise_path_length++;
			}
		}
	}
	clockwise_allowed=(clockwise_path_length<=MAX_PATH_LENGTH);
	...
}
\end{lstlisting}
Nel codice riportato viene eseguito il controllo del percorso richiesto nel caso di ring orario (il codice per il ring antiorario è analogo a questo e perciò non viene descritto). I moduli all'interno del simulatore sono numerati come in Figura~\ref{fig:numerazione-EIB}.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/numerazione-EIB}
	\caption{Numerazione dei moduli all'interno del simulatore}
	\label{fig:numerazione-EIB}
\end{figure}
Su \texttt{clockwise\_path} (o \texttt{counterclockwise\_path}) vengono settati a uno i bit corrispondenti a source e target e tutti i bit compresi tra questi, tenendo conto del percorso orario o antiorario. Per capire meglio si consideri ancora una volta la Figura~\ref{fig:numerazione-EIB}. Si supponga che la SPE6 voglia cominciare una transazione con la SPE0. In tal caso clockwise\_path assumerà i valori riportati in Tabella~\ref{tab:clockwise-path}
\begin{table}[!htbp]
\centering
\begin{tabular}{|c|c|}
	\hline i & clockwise\_path \\
	\hline 0 & 00000000000000000000000000000001 \\
	\hline 1 & 00000000000000000000000000000010 \\
	\hline 2 & 00000000000000000000000000000100 \\
	\hline 3 & 00000000000000000000000000000100 \\
	\hline ... & ... \\
	\hline 8 & 00000000000000000000000010000000 \\
	\hline 9 & 00000000000000000000000100000000 \\
	\hline   & 00000000000000000000000110000111 \\
	\hline
\end{tabular}
	\caption{Calcolo del clockwise\_path}
	\label{tab:clockwise-path} 
\end{table}
\subsection{La funzione path\_analyzer()}
\begin{lstlisting}[caption=Funzione \texttt{path\_analyzer()}, label=lst:listato29]
void path_analyzer()
{
	...
	overlapping = false;
	overlapping_target=false;
	trans_av_flag=false;
	for (int i=0;i<RING_COUNT;i++)
	{
		for (int k=0;k<MAX_COEXISTING_TRANSACTIONS;k++)
		{
			if((target_table[i][k]==required_destination_ID)&&
				(access_table[i][k]!=NULL))
			{
				overlapping_target=(overlapping_target||(true));
			}
		}
	}
	...
	if (overlapping_target==false)
	{
		overlapping=true;
		if(clockwise_path_length < counterclockwise_path_length)
		{
			for (int i=0; (((overlapping)||(transaction_available==false)||
				(overlapping_target))&&(i<RING_COUNT)); i++)
			{
				transaction_available=false;
				overlapping=false;
				for (int j=0; ((j<MAX_COEXISTING_TRANSACTIONS)&&
					(overlapping==false)); j++)
				{
					if(direction_table[i]==CLOCKWISE_DIRECTION)
					{
						if (clockwise_allowed)
						{
							overlapping=(((clockwise_path)&
										(transaction_table[i][j]))!=0);
							path_analyzed=clockwise_path;
							length_path_analyzed = clockwise_path_length;
							selected_ring=i;
						}
						else
						{
							overlapping=true;
						}
					}
				}
			}
			if (overlapping==false)
			{
				while ((j<MAX_COEXISTING_TRANSACTIONS)&&
						(transaction_available==false))
				{
					if (access_table[selected_ring][j]==NULL)
					{
						transaction_available=true;
						selected_transaction=j;
					}
					j++;
				}
				if(transaction_available==false) trans_av_flag = true;
			}
		}
	}
	...
}

\end{lstlisting}
La funzione esegue le seguenti operazioni:
\begin{itemize}
	\item[$\circ$] setta a \texttt{false} i flag \texttt{overlapping}, \texttt{overlapping\_target} e \texttt{trans\_av\_flag};
	\item[$\circ$] controlla su tutti i ring e su tutte le transazioni se il \texttt{required\_source\_ID} è presente nella \texttt{target\_table} (questa contiene tutti i target coinvolti nelle transazioni in corso su \texttt{access\_table});
	\item[$\circ$] se non c'è overlapping target procede alla verifica di overlapping, considerando il ring al quale corrisponde il numero minore di salti tra source e target. Il riscontro viene ottenuto facendo l'and bit a bit tra \texttt{clockwise\_path} e i percorsi corrispondenti alle transazioni in corso (caricati su \texttt{transaction\_table}), se questo è diverso da zero (alcuni bit sono a uno per entrambi i memory access) significa che c'è overlapping.
	\item[$\circ$] se non c'è neanche overlapping cerca tra tutte le transazioni la presenza di una disponibile (sul ring per il quale non è stato riscontrato ne overlapping target ne overlapping).
	\item[$\circ$] \texttt{trans\_av\_flag} viene usato per la generazione delle statistiche e non ha nulla a che vedere con l'implementazione di EIB.
\end{itemize}

\subsection{La funzione analyze\_input()}
\begin{lstlisting}[caption=Funzione \texttt{analyze\_input()}, label=lst:listato30]
void analyze_input()
{
	MemoryAccess* access;
	selected_memory_access = arbitrate();
	if(!_inputStBuffers[selected_memory_access]->is_empty())
	{
		MemoryAccessList::iterator it = 
		_inputStBuffers[selected_memory_access]->begin();
		access = *it;
	}
	else
	{
		if(_inputLdBuffers[selected_memory_access])
		{
			access = _inputLdBuffers[selected_memory_access];
		}
	}
	...
	
	if(!_inputStBuffers[selected_memory_access]->is_empty() || 
		_inputLdBuffers[selected_memory_access])
	{
		required_path_generation(access);
		compute_paths(selected_memory_access, required_destination_ID);
		path_analyzer();
		if(enable_arbitration[selected_memory_access])
		{
			transaction_table[selected_ring][selected_transaction]=path_analyzed;
			target_table[selected_ring][selected_transaction]=
					required_destination_ID;
			source_table[selected_ring][selected_transaction]=
					selected_memory_access;
			...
			access_table[selected_ring][selected_transaction]=access;

		}
		...
	}
	...
}
\end{lstlisting}
La funzione esegue le seguenti operazioni:
\begin{itemize}
	\item[$\circ$] chiama la funzione \texttt{arbitrate()} per determinare quale memory access tra quelli presenti in ingresso deve essere elaborato. A tale scopo, controlla anche che tipo di richiesta è presente (se una load o una store) andando a verificare lo stato dei buffer corrispondenti alla porta selezionata;
	\item[$\circ$] passa al riempimento delle tabelle utilizzate per il controllo della congestione e delle transazioni come: \texttt{transaction\_table}, \texttt{target\_table}, \texttt{source\_table} e \texttt{access\_table}.
\end{itemize}

\section{Raccolta ed elaborazione delle informazioni}
Per rendere possibile la raccolta delle informazioni necessarie alla caratterizzazione delle perfomance di EIB, all'interno della classe \emph{MemoryAccess} sono stati aggiunti degli attributi e dei metodi che consentono, durante l'esecuzione della simulazione, di settarne i valori. Gli attributi in questione sono:
\begin{itemize}
	\item[$\circ$] \emph{\_cycle\_input}: memorizza il numero del ciclo di esecuzione in cui il memory access è stato caricato nel buffer di ingresso di EIB;
	\item[$\circ$] \emph{\_cycle\_output}: memorizza il numero del ciclo di esecuzione in cui il memory access è stato trasferito dalla funzione \emph{route()} all'interno del buffer di uscita;
	\item[$\circ$] \emph{\_overlapping\_target}: memorizza il numero di volte in cui il memory access è stato rifiutato a causa di overlappint\_target;
	\item[$\circ$] \emph{\_overlapping}: memorizza il numero di volte in cui il memory access è stato rifiutato a causa di overlapping;
	\item[$\circ$] \emph{\_not\_transaction\_available}: memorizza il numero di volte in cui il memory access è stato rifiutato a causa della mancanza di una transazione disponibile sui ring;
	\item[$\circ$] \emph{\_lost\_arbitration}: memorizza il numero di volte in cui il memory access perde l'arbitraggio a vantaggio di uno con priorità più alta.
\end{itemize}
I metodi forniti per l'accesso a tali attributi, sono:
\begin{itemize}
	\item[$\circ$] \emph{set\_cycle\_input}: viene invocato durante il \emph{read\_input} per settare il ciclo nel quale il memory access viene caricato sul buffer di ingresso;
	\item[$\circ$] \emph{set\_cycle\_output}: viene invocato durante la \emph{route} per settare il ciclo nel quale il memory access viene trasferito sul buffer di uscita;
	\item[$\circ$] \emph{set\_overlapping}: viene invocato ogni volta che viene riscontato overlapping in modo da incrementare il contatore \emph{overlapping};
	\item[$\circ$] \emph{set\_overlapping\_target}: viene invocato ogni volta che viene rilevato overlapping\_target, in modo da incrementare il contatore \emph{overlapping\_target};
	\item[$\circ$] \emph{set\_not\_transaction\_available}: viene invocato ogni volta il memory access è rifiutato a causa della mancanza di una transazione disponibile sul ring; 
	\item[$\circ$] \emph{set\_lost\_arbitration}: viene invocato ogni volta che il memory access perde l'arbitraggio con uno a più alta priorità.
\end{itemize}
Tutte le informazioni descritte vengono memorizzate all'interno del file \emph{trace\_memory}\-\emph{\_access.txt}. Per quest ultimo sono di seguito riportate, a titolo di esempio, alcune righe:\\
\texttt{\\
----------------\\
MemoryAccess = 0x867fa50\\
Source = 2\\
Target = 0\\
Size = 128\\
State = 1\\
Ring = 1; Transaction = 1\\
Overlapping = 0 ; Destination\_overlapping = 0 ; Available\_transaction = 0 ; Arbitration\_lost = 0\\
Cycle input = 3828794\\
Cycle output = 3828804\\
Latency = 10\\
----------------\\
MemoryAccess = 0x867dc54\\
Source = 0\\
Target = 3\\
Size = 128\\
State = 2\\
Ring = 0; Transaction = 0\\
Overlapping = 0 ; Destination\_overlapping = 0 ; Available\_transaction = 0 ; Arbitration\_lost = 0\\
Cycle input = 3828785\\
Cycle output = 3828807\\
Latency = 22\\
----------------\\
}\\ 
Al fine di estrarre i dati da \emph{trace\_memory\_access.txt}, è stato sviluppato un software per il parsing~\footnote{Con parsing, in informatica, si fa riferimento al processo di analisi di uno stream continuo di input~\cite{wiki-parsing}, proveniente ad esempio da un file.}, \emph{parser.cpp}. Nel caso specifico, \emph{parser} esegue una scansione di \emph{trace\_memory\_access.txt} alla ricerca delle keyword specificate all'interno di un file di configurazione (\emph{parser\_parameters.txt}); queste possono essere ad esempio \emph{State}, \emph{Size}, ecc \ldots Ogni volta che viene trovata una keyword, il suo valore viene confrontato con quello contenuto in \emph{parser\_parameter.txt}. Se tutte le keyword specificate combaciano, i dati, come ad esempio \emph{Latency}, vengono raccolti ed elaborati per produrre il risultato finale dell'analisi. Un esempio di risultato è di seguito riportato: \\
%tramite il quale è anche possibile selezionare il tipo di analisi da svolgere. Una delle analisi che è stata effettuata, per la caratterizzazione delle performance, riguarda la misura della latenza per i memory access di tipo store, aventi una certa dimensione. Un esempio del risultato prodotto dal parser è il seguente:\\
\texttt{\\
Latenza media dei Memory Access = 115\\
Latenza massima dei Memory Access = 368\\
Latenza minima dei Memory Access = 70\\
Numero di Memory Access con state 2 e size 1024 = 32768\\
}\\ 
L'output mostrato è relativo a una misura di latenza media, massima e minima per tutti i memory access di tipo store di dimensione pari a 1024-byte.
%Per la dimensione specificata (1024-byte in questo caso) e per il tipo (store), viene calcolata la latenza media, massima, minima e il numero totale di memory access elaborati.

\section{Parametri di configurazione adottati per il modello di simulazione}
I parametri di configurazione scelti per il modello di simulazione di EIB sono riportati in Tabella~\ref{tab:configuration-parameters2}. Questi vengono confrontati con quelli dell'implementazione CBE di EIB e quella del k-bus di Cellsim. 
\begin{table}[!htbp]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline & Parameter & Cell & CS & CS+EIB \\ 
\hline 
\hline
\multicolumn{5}{|c|}{PPE}\\
\hline PPU & Issue Bandwidth & 2 $\times$ th & 1 & 1\\ 
\hline Cache & Numbero of lines & 512 & 512 & 512\\ 
			 & Line size & 128 & 128 & 128\\ 
        	 & Number of ways & 8 & 8 & 8\\ 
\hline 
\hline
\multicolumn{5}{|c|}{SPE}\\
\hline SPU & Issue Bandwidth & 2 & 2 & 2\\
\hline LS & Size (KB) & 256 & 256 & 256\\
	      & Latency (cycles) & 6 & 6 & 6\\
	      & Number of ports & 1 & 3 & 3\\
\hline MFC & DMA cmd queue size & 16 & 16 & 16\\
 	       & DMA cmd processing & & &\\
	       & Delay (cycles) & ... & 30 & 30\\
\hline

\hline EIB & \# of ring/buses & 4 & 3-4-5 & 2-4-8\\
 	       & BW (B/cycles) & 8 & 8 & 8 (memory, PPE) ; 16 (SPE) \\
	       & Number of outstanding & & &\\
		   & transfers/node & 16 & 16 & 4-40\\	  
\hline
\end{tabular}
\caption{Configurazione EIB confrontata con Cell e Cellsim (CS)}
\label{tab:configuration-parameters2}
\end{table} 
