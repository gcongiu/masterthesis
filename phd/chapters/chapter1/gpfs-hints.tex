%!TEX root = ../../main.tex
\section{The GPFS Hints API}
\label{sec: gpfs_hints_api}
Similarly to POSIX advice, GPFS provides users with the ability to control page pool functions through the \texttt{gpfs\_fcntl()} subroutine: $$\textit{\textbf{int} gpfs\_fcntl(\textbf{int} fileDesc, \textbf{void}* fcntlArgP)}$$ The subroutine takes two inputs: the file descriptor of the open file that hints will be applied to, and a pointer to a data structure residing in the application's address space. The indicated data structure contains all the information regarding what hints should be sent to GPFS. Specific hints are described by means of additional data structures that are contained in the main struct. Table~\ref{table: hints_table} summarizes all the available hints data structures and reports the corresponding description for each of them.

\begin{table}[!htb]
\centering
\ra{1.5}
\caption{GPFS hint data structures}
\newcolumntype{K}{>{\centering\arraybackslash} m{4.2cm}}
\newcolumntype{V}{>{\centering\arraybackslash} m{6cm}}
\begin{tabular}{KV}
\toprule
\bf \small Hint data structure & \bf \small Description \\
\midrule
\small \ttfamily gpfsAccessRange\_t & \small defines a file range to be accessed \\
\small \ttfamily gpfsFreeRange\_t & \small defines a file range to be released \\
\small \ttfamily gpfsMultipleAccessRange\_t & \small defines multiple file ranges to be accessed \\
\small \ttfamily gpfsClearFileCache\_t & \small releases all the page pool buffers for a certain file \\
\bottomrule
\end{tabular}
\label{table: hints_table}
\end{table}

Hints are not mandatory and GPFS can decide to accept or ignore them depending on specific conditions. Let us consider the multiple access range hint as an example (\texttt{gpfsMultipleAccessRange\_t} in table~\ref{table: hints_table}). The data structure corresponding to this hint is reported in Listing~\ref{list: mar}. 

\begin{lstlisting}[language=C, caption=Multiple Access Range Hint Data Structure, label={list: mar}]
#define GPFS_MAX_RANGE_COUNT 8

typedef struct
{
    int structLen;
    int structType;
    int accRangeCnt;
    int relRangeCnt;
    gpfsRangeArray_t accRangeArray[GPFS_MAX_RANGE_COUNT];
    gpfsRangeArray_t relRangeArray[GPFS_MAX_RANGE_COUNT];

} gpfsMultipleAccessRange_t;
\end{lstlisting}

\texttt{gpfsMultipleAccessRange\_t} contains two range arrays instead of just one: \texttt{accRangeArray}, used to define \texttt{accRangeCnt} blocks of the file that GPFS has to prefetch, and \texttt{relRangeArray} used to define \texttt{relRangeCnt} blocks of the file previously requested using \texttt{accRangeArray} and that are no longer needed. Unlike posix\_fadvise the user has to manage the list of blocks for which hints have been sent, updating whether they are still needed. Indeed, if the accessed blocks are not released, GPFS will stop accepting new hints once the maximum internal number of prefetch requests has been reached. 

\begin{lstlisting}[language=C, caption=Multiple Access Range Hint Initialisation and Submission, label={list: mar_example}]
void mercury::BlockCache::gpfsAccessReleaseBlock(
    std::vector<mercury::block_t>& access, 
    std::vector<mercury::block_t>& release)
{
  struct
  {
    gpfsFcntlHeader_t hdr;
    gpfsMultipleAccessRange_t marh;
  } accHint;

  accHint.hdr.totalLength = sizeof(accHint);
  accHint.hdr.fcntlVersion = GPFS_FCNTL_CURRENT_VERSION;
  accHint.hdr.fcntlReserved = 0;
  accHint.marh.structLen = sizeof(accHint.marh);
  accHint.marh.structType = GPFS_MULTIPLE_ACCESS_RANGE;
  accHint.marh.accRangeCnt = access.size();
  accHint.marh.relRangeCnt = release.size();

  for (i = 0; i < accHint.marh.accRangeCnt && 
      i < GPFS_MAX_RANGE_COUNT; i++)
  {
    accHint.marh.accRangeArray[i].blockNumber = 
      access[i].blockNumber_;
    accHint.marh.accRangeArray[i].start = 
      access[i].startOffset_;
    accHint.marh.accRangeArray[i].length = 
      access[i].blkLen_;
    accHint.marh.accRangeArray[i].isWrite = 
      access[i].isWrite_;
  }
  for (i = 0; i < accHint.marh.relRangeCnt && 
      i < GPFS_MAX_RANGE_COUNT; i++)
  {
    accHint.marh.relRangeArray[i].blockNumber = 
      release[i].blockNumber_;
    accHint.marh.relRangeArray[i].start = 
      release[i].startOffset_;
    accHint.marh.relRangeArray[i].length = 
      release[i].blkLen_;
    accHint.marh.relRangeArray[i].isWrite = 
      release[i].isWrite_;
  }

  /* issue the hints to gpfs */
  if (gpfs_fcntl(fd_, &accHint))
  {
    std::cerr << "gpfs_fcntl access hint failed for " <<
      fd_ << " errno=" << errno << " errorOffset=" <<
      accHint.hdr.errorOffset << std::endl;
    exit(EXIT_FAILURE);
  }

  /* remove the accessed and released blocks */
  access.erase(access.begin(), 
    access.begin() + accHint.marh.accRangeCnt);
  release.erase(release.begin(), 
    release.begin() + accHint.marh.relRangeCnt);
}
\end{lstlisting}

Listing~\ref{list: mar_example} shows an example for the multiple access range hint initialisation and submission. In the example the \codeword{gpfsAccessReleaseBlock()} function receives two vectors, each containing a number of regions that have to be prefetched (\texttt{access}) and released (\texttt{release}). Every access and release region defines the block number the current request starts from (\texttt{blockNumber\_}), the start offset inside the block (\texttt{startOffset\_}), the length of the block (\texttt{blkLen\_}) and if the request is a read or a write (\texttt{isWrite\_}). For every requested range the implementation fills the \codeword{accRangeArray} and the \codeword{relRangeArray} and finally submits the data structure to \codeword{gpfs\_fcntl()} to be served.
