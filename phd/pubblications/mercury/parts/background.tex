%!TEX root = ../main.tex
\section{Background on Guided I/O Interfaces}
\label{sec: background}
In this section we describe in detail the POSIX advice provided by the Linux kernel as well as the GPFS hints. Some of the specifics presented in this section will be useful to understand our design choices explored in Section~\ref{sec: concept}.  

\subsection{The POSIX Advice API}
\label{subsec: posix_advice_api}
The Linux kernel allows users to control page cache functionalities through the \texttt{posix\_fadvise()} system call: $$\textit{\textbf{int} posix\_fadvise(\textbf{int} fd, \textbf{off\_t} offset, \textbf{off\_t} len, \textbf{int} advice)}$$ This system call takes four input parameters: a valid file descriptor representing an open file, starting offset and length of the file region the advice will apply to, and finally the type of advice. The implementation provides five different types of advice, that reflect different aspects of caching. 

\begin{table}[h]
    \caption{Values for \textit{advice} in the \textit{posix\_fadvise()} system call}
\centering
\resizebox{0.85\textwidth}{!}{\begin{minipage}{\textwidth}
\begin{tabular}{ | l | l |}
\hline\hline
\normalsize & \\
\normalsize Advice & \normalsize Description \\[0.5ex]
\hline
 \normalsize & \\
 \normalsize\ttfamily POSIX\_FADV\_SEQUENTIAL & \normalsize file access pattern is sequential \\[0.5ex]
 \normalsize\ttfamily POSIX\_FADV\_RANDOM & \normalsize file access pattern is random \\[0.5ex]
 \normalsize\ttfamily POSIX\_FADV\_NORMAL & \normalsize reset file access pattern to normal \\[0.5ex]
 \normalsize\ttfamily POSIX\_FADV\_WILLNEED & \normalsize a file region will be needed \\[0.5ex]  
 \normalsize\ttfamily POSIX\_FADV\_DONTNEED & \normalsize a file region will not be needed \\[0.5ex]
 \normalsize\ttfamily POSIX\_FADV\_NOREUSE & \normalsize file is read once (not implemented) \\[0.5ex]
\hline
\end{tabular}
\end{minipage}}
\label{table: advice_table}
\end{table}  

The first two advice in Table~\ref{table: advice_table} have an impact on spatial locality of elements of the cache. \texttt{POSIX\_FADV\_SEQUENTIAL} can be used to advise the kernel that a file will be accessed sequentially. As result the kernel will double the maximum read-ahead window size in order to have a greedier read-ahead algorithm. \texttt{POSIX\_FADV\_RANDOM}, on the other hand, can be used when a file is accessed randomly and has the effect of completely disabling read-ahead, therefore only ever reading the requested data. Finally, \texttt{POSIX\_FADV\_NORMAL} can be used to cancel the previous two advice-messages and reset the read-ahead algorithm to its defaults. These three advice types apply to the whole file, the offset and length parameters are ignored for these `modes'.

Two of the remaining three advice types have an impact on the temporal locality of cache elements. \texttt{POSIX\_FADV\_WILLNEED} can be used to advise the kernel that the defined file region will be accessed soon, and therefore the kernel should prefetch the data and make it available in the page cache. \texttt{POSIX\_FADV\_DONTNEED} has the opposite effect, making the kernel release the specified file region from the cache, on the condition that the corresponding pages are clean (dirty pages are not released). Finally, the implementation for \texttt{POSIX\_FADV\_NOREUSE} is not provided in the kernel. %Table~\ref{table: advice_table} summarizes all the advice types just described.

One important aspect of \texttt{posix\_fadvise()} is that it is a synchronous system call. This means that every time an application invokes it, it blocks and returns only after the triggered read-ahead operations have completed. This represents a big limitation especially if we consider \texttt{POSIX\_FADV\_WILLNEED} that may need to prefetch an arbitrarily large chunk of data. In this scenario the application may be idle for a long period of time while the data is being retrieved by the file system.

%\subsection{POSIX Advice in the Linux Kernel}
%\label{subsec: posix_advice_kernel}

\subsection{The GPFS Hints API}
\label{subsec: gpfs_hints_api}
Similarly to POSIX advice, GPFS provides users with the ability to control page pool functions through the \texttt{gpfs\_fcntl()} subroutine: $$\textit{\textbf{int} gpfs\_fcntl(\textbf{int} fileDesc, \textbf{void}* fcntlArgP)}$$ The subroutine takes two inputs: the file descriptor of the open file that hints will be applied to, and a pointer to a data structure residing in the application's address space. The indicated data structure contains all the information regarding what hints should be sent to GPFS. Specific hints are described by means of additional data structures that are contained in the main struct. Table~\ref{table: hints_table} summarizes all the available hints data structures and reports the corresponding description for each of them.

\begin{table}[h]
    \caption{Data structures provided by GPFS to describe different hints}
\centering
\resizebox{0.85\textwidth}{!}{\begin{minipage}{\textwidth}
\begin{tabular}{ | l | p{4.4cm}|}
\hline\hline
\normalsize & \\
\normalsize Hint data structure & \normalsize Description \\[0.5ex]
\hline
 \normalsize & \\
 \normalsize\ttfamily gpfsAccessRange\_t & \normalsize defines a region of the file that needs to be accessed \\ [0.5ex]
 \normalsize\ttfamily gpfsFreeRange\_t & \normalsize defines a region of the file that needs to be released \\ [0.5ex]
 \normalsize\ttfamily gpfsMultipleAccessRange\_t & \normalsize defines multiple regions of the file that needs to be accessed \\ [0.5ex]
 \normalsize\ttfamily gpfsClearFileCache\_t & \normalsize releases all the page pool buffers held by a certain file \\ [0.5ex]  
\hline
\end{tabular}
\end{minipage}}
\label{table: hints_table}
\end{table}  

Hints are not mandatory and GPFS can decide to accept or ignore them depending on specific conditions. Let us consider the multiple access range hint as an example (\texttt{gpfsMultipleAccessRange\_t} in table~\ref{table: hints_table}). The data structure corresponding to this hint is reported in Listing~\ref{mar}. \\
\\
\\

\lstset{
        captionpos=b,
        language=C,
        keywordstyle=\color{blue}\footnotesize\ttfamily,
        breaklines=true,
        basicstyle=\footnotesize\ttfamily,
        caption={Multiple access range hint data structure},
        label=mar
}
\begin{lstlisting}[frame=single]
#define GPFS_MAX_RANGE_COUNT 8
#define MAX_RANGE_COUNT GPFS_MAX_RANGE_COUNT

typedef struct 
{
    int              structLen;      
    int              structType;     
    int              accRangeCnt;    
    int              relRangeCnt;    
    gpfsRangeArray_t accRangeArray[MAX_RANGE_COUNT];
    gpfsRangeArray_t relRangeArray[MAX_RANGE_COUNT];

} gpfsMultipleAccessRange_t; 
\end{lstlisting}

\texttt{gpfsMultipleAccessRange\_t} contains two range arrays instead of just one: \texttt{accRangeArray}, used to define \texttt{accRangeCnt} blocks of the file that GPFS has to prefetch, and \texttt{relRangeArray} used to define \texttt{relRangeCnt} blocks of the file previously requested using \texttt{accRangeArray} and that are no longer needed. Unlike posix\_fadvise the user has to manage the list of blocks for which hints have been sent, updating whether they are still needed. Indeed, if the accessed blocks are not released, GPFS will stop accepting new hints once the maximum internal number of prefetch requests has been reached. %The same applies to file regions accessed through \texttt{gpfsAccessRange\_t} that need to be released once they are no longer needed using \texttt{gpfsFreeRange\_t}.


