\chapter{Wrapper SystemC-Unisim per NoC $\times$pipes}\label{cap:capitolo5}

In questo capitolo viene sviluppata la seconda parte del lavoro di tesi; questa verte sull'integrazione, all'interno di Cellsim, del modello di simulazione cycle accurate (CA) della network on chip $\times$pipes. Più precisamente viene sviluppato un modulo wrapper (involucro) che incamera al suo interno il codice SystemC della network on chip e ne permette l'interazione con quello del simulatore del processore Cell. Ciò è reso possibile grazie all'interoperabilità fornita dal framework UNISIM (Capitolo~\ref{cap:capitolo2}) che consente l'impiego, all'interno di Cellsim, di moduli realizzati con altri ambienti di sviluppo, come appunto SystemC, ma non solo.\\
Il capitolo è organizzato come segue: nella prima parte viene fatta una breve introduzione alla libreria C++ SystemC, in modo da mettere in evidenza gli elementi chiave che stanno alla base dell'integrazione; nella seconda parte vengono descritte le scelte architetturali adottate per rendere compatibile il modello di simulazione di $\times$pipes con quello del processore Cell; nella terza parte del capitolo viene descritta in dettaglio l'implementazione del modulo wrapper e l'integrazione dei due ambienti di sviluppo.\\
Il capitolo si conclude con una descrizione dei parametri architetturali della network on chip utilizzata nel lavoro di tesi.

\section{La libreria SystemC}

SystemC è una libreria C++ costituita da un set di definizioni di classe per le quali fornisce anche una metodologia di utilizzo. La libreria e il kernel di simulazione estendono lo standard C++ in modo da rendere possibile la modellazione dei sistemi. L'estensione include strumenti per la definizione di comportamenti concorrenti, l'introduzione della nozione di tempo nell'esecuzione delle operazioni, tipi di dato per la descrizione dell'hardware, strutture gerarchiche e supporto alla simulazione.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.5]{figure/sc-language-architecture}
	\caption{SystemC language architecture. I riquadri evidenziati in grigio fanno parte del SystemC core language standard}
 	\label{fig:sc-language-architecture}
\end{figure}
Nella Figura~\ref{fig:sc-language-architecture} sono evedenziati in grigio i riquadri che identificano gli elementi base dello standard:
\begin{itemize}
	\item[$\circ$] il nucleo del linguaggio (Core Language) è rappresentato da un simulatore guidato dagli eventi (Event-driven), da moduli e porte per la realizzazione delle strutture, interfacce e canali per la descrizione delle comunicazioni;
	\item[$\circ$] i tipi di dato (Data Types) sono utili per la modellazione hardware e per certi tipi di programmazione software;
	\item[$\circ$] i canali primitivi (Primitive Channels) sono largamente impiegati come segnali e FIFO.
\end{itemize}
Un sistema in SystemC è rappresentato tramite un set di uno o più moduli; questi forniscono la capacità di descriverne la struttura e tipicamente contengono processi, porte, dati interni, canali, istanze di altri moduli. Tutti i processi sono concettualmente concorrenti e possono essere utilizzati per modellare le funzionalità del modulo. Le porte sono oggetti tramite i quali i moduli comunicano tra loro. I dati interni e i canali forniscono gli strumenti di comunicazione tra i processi e conservano lo stato del modulo. Le istanze dei moduli permettono di realizzare strutture gerarchiche. 
%La comunicazione dei processi all'interno di moduli differenti è ottenuta utilizzando porte, interfacce e canali. La porta di un modulo è l'oggetto tramite il quale i processi accedono alle interfacce dei canali, le quali definiscono un set di funzioni che vengono poi implementate dal canale stesso. Durante l'elaborazione le porte di un modulo sono connesse (bound) ai canali designati.\\
%Interfacce, porte e canali forniscono grande flessibilità nella modellazione delle comunicazioni e nel rifinimento di un modulo. I processi sono attivati a partire dall'occorrenza di uno o più eventi. 

\subsection{Utilizzo della SystemC library}
L'accesso a tutte le classi e le funzioni SystemC è fornito da un singolo header file chiamato \texttt{systemc.h}; l'utente che intenda utilizzare la libreria non deve fare altro che includere questo header file nel proprio codice.

\subsection{Semantica di esecuzione}
SystemC è un ambiente di simulazione basato sugli eventi; ciò significa che l'evoluzione del flusso di elaborazione non è legata solo al trascorrere del tempo, ma anche al verificarsi di particolari avvenimenti, chiamati appunto eventi. Il tempo, nel simulatore, parte dal valore t = 0 e aumenta progressivamente durante il processing.  
%SystemC è un ambiente di simulazione basato sugli eventi che occorrono durante l'esecuzione. Il tempo parte dall'istante t = 0 ed evolve a partire da tale valore. L'incremento temporale è definito tramite la scala e la risoluzione.

\subsubsection{main() \& sc\_main()}
La funzione main() è parte della SystemC library, questa chiama la funzione sc\_main() che rappresenta il punto di accesso alla libreria, da parte del codice utente. 

\subsubsection{Elaborazione}
L'elaborazione è definita come l'esecuzione della funzione sc\_main(), dal suo inizio fino alla prima invocazione di sc\_start(). L'elaborazione può includere la costruzione delle istanze dei moduli e dei canali per connetterli, la definizione dell'oggetto sc\_clock e delle variabili sc\_time. Durante questa fase gli elementi strutturali del sistema vengono creati e connessi secondo la gerarchia. Quando un modulo viene creato, questo istanzia tutti i sotto-blocchi che lo compongono e che sono collegati tramite porte e canali. Infine, si passa alla connessione dei top module del progetto, ovvero quei moduli che sono più alti nella gerarchia. 

\subsubsection{Semantica per la simulazione}
Lo scheduler controlla la temporizzazione e l'ordine di esecuzione dei processi, gestendo inoltre la notifica degli eventi e l'aggiornamento dei canali. Questo supporta la nozione di delta-cycle per l'evoluzione del tempo di simulazione. I processi in SystemC sono detti non-preemptive. Ciò significa che per i processi thread, il codice delitimato da due istruzioni di \texttt{wait()} viene eseguito senza nessuna interruzione da parte di altri e i processi method completano la loro esecuzione senza nessuna interruzione. 
Lo scheduler viene invocato mediante la chiamata della funzione sc\_start(). L'esecuzione può essere prolungata per un determinato ammontare di tempo, specificato all'interno della funzione. Una volta che lo scheduler ha terminato, l'esecuzione può continuare a partire dall'istante nel quale era stata interrotta tramite l'invocazione della funzione sc\_start().

\subsubsection{Scheduler}
La semantica dello scheduler SystemC è definita attraverso i seguenti otto passi:
\begin{enumerate}
	\item \textbf{Fase di inzializzazione}. In questa fase vengono eseguiti tutti i processi method (per intero) e quelli thread (finché non viene trovata un'istruzione \texttt{wait()}).
	\item \textbf{Fase di valutazione}. Tutti i processi pronti per l'esecuzione si trovano in una coda dalla quale vengono risvegliati uno dopo l'altro; l'ordine con il quale questo avviene non è specificato. Durante l'esecuzione di un processo è possibile che venga generato un evento al quale fa seguito il passaggio di un altro allo stato ready to run. In questo caso il processo in esame, viene messo nella coda insieme agli altri per poi essere eseguito durante la stessa fase. Inoltre se il valore di un segnale (canale primitivo) subisce un cambiamento, viene generata una richiesta di \texttt{update()}, schedulata tramite la funzione \texttt{request\_update()} (richiamata all'interno delle funzioni membro di un canale primitivo) e eseguita durante la successiva fase di update.
	\item Il passo precedente viene ripetuto per tutti i processi pronti all'esecuzione. 
	\item \textbf{Fase di update}. Tutte le chiamate pendenti ad \texttt{update()} vengono soddisfatte.
	\item Se sono ancora presenti notifiche pendenti, determina quali processi sono pronti ad essere eseguiti e torna alla fase di valutazione. 
	\item Se non ci sono altre notifiche di eventi pendenti, la simulazione termina.
	\item In caso contrario il tempo di simulazione viene incrementato.
	\item Vengono identificati i processi pronti all'esecuzione e si ritorna al passo 2.
\end{enumerate}

\subsection{Modello di tempo}
SystemC usa un modello di tempo assoluto. Questo viene rappresentato internamente tramite un intero senza segno di almeno 64-bit. Il conteggio parte da t = 0 e va avanti con valori sempre crescenti.

\subsubsection{sc\_time}
Il tipo \texttt{sc\_time} viene utilizzato per rappresentare il tempo o intervalli di esso. Un oggetto \texttt{sc\_time} è rappresentato tramite un valore numerico (di tipo \texttt{double}) e un'unità temportale (di tipo \texttt{sc\_time\_unit}).

\subsubsection{Risoluzione temporale}
La risoluzione temporale è la più piccola quantità di tempo che può essere rappresentata tramite un oggetto \texttt{sc\_time} all'interno di una simulazione. Il valore di default per la risoluzione temporale è a pari a 1 picosecondo ($10^{-12} sec$). Tale valore può essere cambiato dall'utente invocando la funzione \texttt{sc\_set\_time\_resolution()}, questa va chiamata prima dell'oggetto \texttt{sc\_time}.

\subsubsection{Unità temporale di default}
I valori di tempo possono anche essere specificati semplicemente tramite un numero, ommettendo l'unità. In questi casi il valore di riferimento è implicitamente definito dalla default time unit. Tale valore è pari a 1 nanosecondo ($10^{-9} sec$).
Un esempio di utilizzo potrebbe essere quello di specificare il tempo di esecuzione all'interno della funzione 
\texttt{sc\_start()}:
%\begin{table}[!htbp]
\begin{lstlisting}[caption=Esempio di utilizzo del default time unit nella funzione \texttt{sc\_start()}.,label=lst:default-time-unit]
// run simulation for 1000 time units
// default time unit = 1ns
sc_start(1000);
\end{lstlisting}
%\end{table}
Il valore di default time unit può essere cambiato dall'utente tramite la funzione \texttt{sc\_set\_default\_time\_unit()}.

\subsection{La funzione sc\_main()}
Come detto precedentemente, la funzione \texttt{sc\_main()} rappresenta il punto di ingresso tramite il quale il codice utente ha accesso alla libreria SystemC. Questa viene chiamata tramite la funzione \texttt{main()}. Il suo prototipo è:
\begin{lstlisting}[caption=Prototipo della funzione \texttt{sc\_main()}.,label=lst:sc-main]
int sc_main( int argc, char* argv[] );
\end{lstlisting}
\texttt{argc} e \texttt{argv[]} sono gli argomenti standard che vengono passati da riga di comando.
Il corpo della \texttt{sc\_main()} tipicamente contiene le variabili di configurazione della simulazione (default time unit, time resolution, ecc \ldots), nonché le istanze di moduli, canali, ecc \ldots
L'elaborazione è definita come l'esecuzione della funzione \texttt{sc\_main()} a partire dall'inizio fino alla prima invocazione di \texttt{sc\_start()}.
\begin{lstlisting}[caption=Esempio di funzione \texttt{sc\_main()}.,label=lst:sc-main]
int sc_main(int argc, char* argv[ ]){
// Create FIFO channels with a depth of 10
sc_fifo<int> s1(10);
sc_fifo<int> s2(10);
sc_fifo<int> s3(10);
// Module instantiations
// Stimulus Generator
stimgen stim("stim");
stim(s1, s2);
// Adder
adder add("add");
add(s1, s2, s3);
// Response Monitor
monitor mon("mon");
mon.re(s3);
// Start simulation
sc_start(); // run indefinitely
return 0;
} // end sc_main()
\end{lstlisting}

%\subsubsection{Istanza di un modulo}
%La costruzione delle istanze dei top module viene fatta all'interno della funzione \texttt{sc\_main()} prima che venga chiamata per la prima volta \texttt{sc\_start()}. La sintassi utilizzata per creare l'istanza di un modulo è la seguente:
%\begin{lstlisting}[caption=Esempio di istanza di un modulo,label=lst:modules]
%module_type module_instance_name(string_name);
%\end{lstlisting}
%dove: \texttt{module\_type} è il tipo di modulo (classe derivata da \texttt{sc\_module}; \texttt{module\_instance\_name} è il nome dell'istanza del modulo (nome dell'oggetto); \texttt{string\_name} è la stringa utilizzata per inizializzare l'istanza del modulo. 

%\subsubsection{Binding delle porte}
%Dopo che un modulo è stato istanziato all'interno di \texttt{sc\_main()} bisogna collegare le sue porte ai canali. Ci sono due diversi modi per fare questo:
%\begin{itemize}
%	\item[$\circ$] binding per nome: la porta viene esplicitamente collegata al canale
%	\begin{lstlisting}[caption=Esempio di binding di un modulo esplicitando il nome della porta,label=lst:name-binding]
%	module_instance_name.port_name(channel_name) ;
%	\end{lstlisting}
%	dove \texttt{port\_name} è il nome della porta da collegare e \texttt{channel\_name} è il nome dell'istanza del canale alla quale la porta è collegata;
%	\item[$\circ$] binding per posizione: le porte sono collegate ai canali seguendo l'ordine con cui queste vengono dichiarate all'interno del modulo. Il binding posizionale è limitato a quei modulo che hanno un massimo di 64 porte
%	\begin{lstlisting}[caption=Esempio di binding di un modulo utilizzando la notazione posizionale,label=lst:positional-binding]
%	module_instance_name(channel_name1, channel_name2, ... ) ;
%	\end{lstlisting}
%	\texttt{channel\_nameX} è il nome del canale al quale la porta è collegata. Il primo canale nella lista è collegato alla prima porta in \texttt{module\_instance\_name} e così via per tutti gli altri.
%\end{itemize}

\subsection{Moduli}
SystemC, come altri linguaggi di descrizione dell'hardware (HDL), adotta un approccio alla modellazione dei sistemi di tipo strutturale. Ciò significa che le unità funzionali del sistema vengono rappresentate, nel simulatore, tramite entità strutturali base chiamate moduli. Un modulo è, sostanzialmente, una classe C++ alla quale vengono aggiunte delle funzionalità integrative SystemC come:
%In SystemC il modulo è il blocco strutturale di base. Questo è una classe contenitore nella quale sono istanziati processi e altri moduli. I moduli possono contenere:
\begin{itemize}
	\item[$\circ$] Porte per la comuncazione
	\item[$\circ$] Dati membro
	\item[$\circ$] Canali
	\item[$\circ$] Processi
	\item[$\circ$] Funzioni membro non registrate come processi
	\item[$\circ$] Istanze di altri moduli
\end{itemize}

\subsubsection{Struttura di un modulo}
I moduli sono definiti a partire dalla classe \texttt{sc\_module}
\begin{lstlisting}[caption=Definizione di un modulo,label=lst:module-definition]
class my_module	: public sc_module{...};
\end{lstlisting}
Alternativamente può essere utilizzata, per la definizione, la macro \texttt{SC\_MODULE}.
\begin{lstlisting}[caption=Definizione di un modulo utilizzando la macro \texttt{SC\_MODULE},label=lst:module-definition2]
SC_MODULE(module_name) {
	// ports, data members, member functions		
	// processes etc.
	SC_CTOR(module_name) { // Constructor
		// body of constructor
		// process registration, sensitivity lists
		// module instantiations, port binding etc.
	}
};
\end{lstlisting}
Questa fornisce una forma semplice per la definizione del modulo.
\begin{lstlisting}[caption=Definizione della macro \texttt{SC\_MODULE},label=lst:sc-module]
#define SC_MODULE(user_module_name) \
	struct user_module_name : sc_module
\end{lstlisting}
\texttt{SC\_MODULE} non fa altro che derivare la classe \texttt{user\_module\_name} dalla classe base \texttt{sc\_module}.

\subsubsection{Costruttore}
Essendo i moduli delle classi C++ (classi derivate da \texttt{sc\_module}), come queste, richiedono un costruttore per la creazione delle proprie istanze. Il costruttore è definito tramite la macro \texttt{SC\_CTOR}, che prende come parametro una stringa rappresentante il nome dell'istanza. Nel caso in cui siano necessari parametri aggiuntivi, il costruttore deve essere dichiarato esplicitamente dall'utente. In tal caso il primo argomento deve essere di tipo \texttt{sc\_module\_name}, che è la classe utilizzata per gestire il nome dell'oggetto.
\begin{lstlisting}[caption=Definizione del costruttore da parte dell'utente,label=lst:constructor]
SC_MODULE(my_module) {
	// ports, channels, data members
	int some_parameter;
	// processes etc.
	my_module (sc_module_name name, int some_value):
		sc_module(name), some_parameter(some_value){
			// constructor body
	}
};
\end{lstlisting}
Se un modulo ha dei processi e la macro \texttt{SC\_CTOR} non viene utilizzata, allora deve essere presente la macro \texttt{SC\_HAS\_PROCESS}.

\subsubsection{Istanza di un modulo}
I moduli possono essere istanziati all'interno di altri per creare delle gerarchie. L'istanza viene creata in due passi: dichiarazione e inizializzazione. Un terzo passo aggiuntivo, il binding delle porte, è richiesto nel caso in cui il modulo abbia definito qualche porta. 
L'istanza viene realizzata seguendo due possibili approcci: uno prevede l'utilizzo di puntatori mentre l'altro no. Nei due casi la sintassi adottata per istanza e inizializzazione del modulo differiscono, resta invece invariata quella per il binding delle porte. 
Quando il modulo viene istanziato gli viene assegnata una stringa per rappresentarne il nome; tale stringa non deve per forza coincidere con il nome dell'istanza.\\ 
La sintassi utilizzata per istanziare un modulo è simile a quella utilizzata per definire i dati membro all'interno di una classe C++:
\begin{lstlisting}[caption=Sintassi utilizzata nell'istanza di modulo,label=lst:module-instance]
SC_MODULE(ex3) {
	// Ports
	sc_fifo_in<int> a;
	sc_fifo_out<int> b;
	// Internal channel
	sc_fifo<int> ch1;
	// Instances of module types ex1 and ex2
	ex1 ex1_instance;
	ex2 ex2_instance;
	// Module Constructor
	SC_CTOR(ex3){
		// Constructor body not shown
	}
	// Rest of the module body not shown
};
\end{lstlisting}
Dopo che è stato istanziato il modulo deve essere inizializzato:
\begin{table}[!htbp]
\begin{lstlisting}[caption=Sintassi utilizzata per l'inizializzazione di un modulo,label=lst:module-initialization]
SC_MODULE(ex3){
	// Ports
	sc_fifo_in<int> a;
	sc_fifo_out<int> b;
	// Internal channel
	sc_fifo<int> ch1;
	// Instances of module type ex1 and ex2
	ex1 ex1_instance;
	ex2 ex2_instance;
	// Module Constructor
	SC_CTOR(ex3): ex1_instance("ex1_instance"),
		ex2_instance("ex2_instance")
	{
		// Rest of constructor body not shown
	}	
	// Rest of the module body not shown
};
\end{lstlisting}
\end{table}
E' possibile impiegare anche una sintassi alternativa che faccia uso di puntatori:
\begin{lstlisting}[caption=Sintassi utilizzata nell'istanza di modulo facendo uso di puntatori,label=lst:module-instance-pointer]
SC_MODULE(ex3) {
	// Ports
	sc_fifo_in<int> a;
	sc_fifo_out<int> b;
	// Internal channel
	sc_fifo<int> ch1;
	// Pointers to instances of module type ex1
	// and ex2
	ex1 *ex1_instance;
	ex2 *ex2_instance;
	// Module Constructor
	SC_CTOR(ex3){
		// Constructor body not shown
	}
	// Rest of the module body not shown
};
\end{lstlisting}
In questo caso allocazione e inzializzazione del modulo vengono fatte tramite comando \texttt{new} all'interno del corpo del costruttore:
\begin{lstlisting}[caption=Sintassi utilizzata nell'inizializzazione di un modulo facendo uso del comando \texttt{new},label=lst:module-instance-inizialization]
SC_MODULE(ex3){
	// Ports
	sc_fifo_in<int> a;
	sc_fifo_out<int> b;
	// Internal channel
	sc_fifo<int> ch1;
	// Pointers to instances of module type ex1
	// and ex2
	ex1 *ex1_instance;
	ex2 *ex2_instance;
	// Module Constructor
	SC_CTOR(ex3){
		// allocate and initialize both instances
		ex1_instance = new ex1(ex1_in_ex3");
		ex2_instance = new ex2("ex2_in_ex3");
		// Rest of constructor body not shown
	}
	// Rest of the module body not shown
};
\end{lstlisting}

\subsection{Interfacce, porte e canali}
Gli elementi base forniti per la comunicazione all'interno del modulo sono rappresentati da interfacce, porte e canali. Un'interfaccia definisce un set di funzioni (metodi) di accesso al canale, mentre quest ultimo si occupa di implementazione dei metodi. Le porte sono gli oggetti attraverso i quali è possibile accedere ai canali.

\subsubsection{Interfacce}
Un'interfaccia definisce un set di funzioni membro. Questa è puramente funzionale, ovvero non fornisce alcuna implementazione ma specifica semplicemente la firma di ogni funzione: nome, parametri, tipo restituito; in nessun modo quali tipi di operazioni queste implementano.  

\subsubsection{Canali}
I canali contengono l'implementazione delle funzioni membro definite all'interno dell'interfaccia. Essi forniscono il supporto per la comunicazione tra moduli oppure, all'interno di un modulo, quella tra processi. Ogni canale può implementare una o più interfacce e canali diversi possono implementare la stessa interfaccia in modi diversi. SystemC identifica due tipi di canali: canali primitivi e canali gerarchici. Per quanto riguarda i canali primitivi sono disponibili:
\begin{itemize}
	\item[$\circ$] sc\_buffer
	\item[$\circ$] sc\_signal
	\item[$\circ$] sc\_fifo
	\item[$\circ$] sc\_mutex
	\item[$\circ$] sc\_signal\_rv
	\item[$\circ$] sc\_signal\_resolver
	\item[$\circ$] sc\_semaphore
\end{itemize}

\subsubsection{Porte}
Le porte sono oggetti che forniscono ai moduli il mezzo per la connessione e la comunicazione. Attraverso queste un modulo può comunicare con uno o più canali. Le porte richiedono un'interfaccia e tutte sono derivate dalla classe \texttt{sc\_port}. Un esempio è il seguente:
\begin{lstlisting}[caption=Sintassi utilizzata per la dichiarazione di una porta,label=lst:ports]
SC_MODULE(my_module){
	sc_port<IF, N > port_name ;
	// rest of module not shown
};
\end{lstlisting}
\texttt{sc\_port} prende due parametri di template: un'interfaccia IF alla quale la porta può essere connessa e un numero opzionale N che specifica il numero di interfacce che possono essere collegate. 
In SystemC sono anche definite delle porte, cosidette, specializzate, derivate dalla classe base \texttt{sc\_port} e che sono dedicate all'uso di particolari interfacce. Tipicamente queste porte forniscono supporto aggiuntivo per l'uso di un canale o per renderne più semplice l'utilizzo. Esse includono, per i canali \texttt{sc\_buffer} e \texttt{sc\_signal}:
\begin{itemize}
	\item[$\circ$] \texttt{sc\_in}: porta di ingresso
	\item[$\circ$] \texttt{sc\_out}: porta di uscita 
	\item[$\circ$] \texttt{sc\_inout}: porta di ingresso/uscita
\end{itemize}

\subsection{Processi}
I processi contengono le funzionalità che devono essere espletate da un modulo. Tipicamente nei linguaggi di programmazione, le funzioni sono eseguite in modo sequenziale tramite il passaggio del controllo da una all'altra per modellare il comportamento desiderato. L'esecuzione sequenziale, però, non permette di descrivere sistemi complessi in quanto caratterizzati da attività principalmente concorrenti. In SystemC tutto ciò non è vero, è possibile infatti descrivere le funzionalità di un sistema tramite particolari tipi di funzioni dette processi, modellando il parallelismo. Alcuni processi si comportano esattamente come le funzioni: iniziano quando
sono chiamati e terminano, quando completati, rimandando il controllo indietro al meccanismo di chiamata. Altri processi sono chiamati solo una volta all'inizio della simulazione e rimangono alternativamente attivi o sospesi in attesa del verificarsi o meno di un evento. L'evento può essere il fronte di salita del clock, la variazione
di un canale o entrambe. I processi non sono gerarchici, ovvero non possono attivarne altri direttamente. Essi sono caratterizzati da un lista di eventi (sensitivity list) che ne causano l'attivazione ad ogni occorrenza. Un processo può dunque invocarne un altro indirettamente generando l'evento che è presente nella sensitivity list di quest'ultimo. 
%Questi sono definiti come funzioni membro del modulo e sono invocati ogni volta che si verifica un evento presente nella loro sensitivity list. I processi non sono gerarchici. 
SystemC definisce due tipi di processo: processi method e processi thread. Per le due tipologie vengono fornite le seguenti macro da utilizzare per associare la funzione membro al tipo desiderato: \texttt{SC\_METHOD} e \texttt{SC\_THREAD}. Benché non strettamente necessario, l'uso di queste macro è fortemente raccomandato. 

\subsubsection{Dichiarazione delle funzioni membro}
Un processo è dichiarato come una funzione membro all'interno di un modulo; questo non restituisce niente e non ha argomenti.
\begin{lstlisting}[caption=Dichiarazione di una funzione membro,label=lst:methods]
SC_MODULE(my_module){
	//ports, channels etc. not shown
	// Process function declaration
	void my_proc();
	// rest of module not shown
};
\end{lstlisting}
Una volta definito bisogna registrarne il tipo e questo viene fatto tramite l'ausilio delle macro \texttt{SC\_METHOD} e \texttt{SC\_THREAD}. Tale dichiarazione è inserita all'interno del corpo del costruttore. Entrambe le macro prendono in ingresso un solo parametro, corrispondente al nome della funzione che deve essere definita come processo. 
\begin{lstlisting}[caption=Dichiarazione di una funzione membro come processo,label=lst:process]
SC_MODULE(my_module) {
	void my_thread_proc(); //member function declaration
	void my_method_proc(); //member function declaration
	SC_CTOR(my_module) {
		// thread process declaration and registration
		SC_THREAD(my_thread_proc);
		// method process declaration and registration
		SC_METHOD(my_method_proc);
		// rest of constructor not shown
	}
	// rest of module not shown
};
\end{lstlisting}

\subsubsection{Sensitivity list del processo}
Come detto la sensitivity list contiene la lista di eventi ai quali il processo è sensibile e che ne causano lattivazione ad ogni occorrenza. 
%Un processo è un tipo particolare di metodo che viene eseguito dallo scheduler ogni volta che si verifica un particolare evento, sul quale il processo è sincronizzato. 
La definizione della sensitivity list viene fatta tramite l'uso di \texttt{sensitive} all'interno del costruttore del modulo, dopo la dichiarazione del processo e prima della dichiarazione di quello successivo. La notazione utilizzata per la sua definizione è la seguente:
\begin{table}[!htbp]
\begin{lstlisting}[caption=Sensitivity list di un processo,label=lst:sensitive]
SC_MODULE(my_module) {
	sc_event c;
	sc_event d;
	void my_thread_proc();
	SC_CTOR(my_module) {
		SC_THREAD(my_thread_proc);
		// declare static sensitivity list
		sensitive << c << d; // sensitive to events c & d
}
// rest of module not shown
};
\end{lstlisting}
\end{table}

\subsubsection{Processi SC\_METHOD}
I processi \textbf{METHODs} vengono attivati ogni qualvolta si verifica un evento definito nella loro sensitivity list. Il method restituisce il controllo al kernel di simulazione solo una volta che ha terminato l'esecuzione della sua funzionalità. Tali processi non possono essere sospesi e perciò non possono neanche contenere loop infiniti.

\subsubsection{Processi SC\_THREAD}
A differenza dei method i processi \textbf{THREADs} possono essere interrotti e riattivati. L'interruzione viene ottenuta tramite l'inserimento nel codice della funzione \texttt{wait()}, che ne sospende l'esecuzione fino al verificarsi di un evento; in questo caso l'esecuzione riprende dal punto in cui era stata interrotta dalla \texttt{wait()}.

\section{Variazioni architetturali della Network on Chip}
All'interno del processore Cell, come visto anche nel Capitolo~\ref{cap:capitolo1}, è presente un ulteriore livello nella gerarchia di memoria, rappresentato dalle local store delle SPE. Queste costituiscono l'elemento architetturale chiave adottato dalla CBEA per superare le limitazioni imposte alle performance da parte del memory wall. Grazie alle local store, è possibile avere un gran numero di transazioni concorrenti senza dover richiedere profonde esecuzioni speculative che conducono ad alti gradi di inefficenza in altri sistemi. Ogni SPE può accedere ai dati contenuti nella local store di un'altra SPE tramite comandi DMA eseguiti dal MFC. In questo modo, ad esempio, se una SPE termina di elaborare dei dati intermedi, un'altra può prelevarli per successive elaborazioni. Si potrebbe immaginare, nel caso di un lettore DVD avanzato, che una SPE esegua una prima decodifica dei dati, la seconda SPE provveda ad adattare l'immagine alla risoluzione dello schermo mentre una terza SPE prelevi i dati dalla memoria della prima SPE e decodifichi l'audio digitale adattandolo all'impianto disponibile.\\
Da quanto detto è evidente come non sia possibile identificare, all'interno dell'architettura del Cell, una separazione netta tra entità master ed entità slave. Tutte le SPE sono sia master che slave grazie alla presenza dell'unita MFC. Questo rende le network interface $\times$pipes incompatibili con il modello delle SPE. Secondo quanto previsto dallo stardard OCP, per superare tale ostacolo, sarebbe necessario fornire, ad ogni SPE, due network interface (una master e una slave), raddoppiando quasi il loro numero (2 NI per ogni SPE più 2 per memoria e PPE). Ai fini del lavoro di tesi questo rappresenta un'inutile complicazione del modello, che può essere però superata modificando l'architettura della network interface. 

\subsection{Modello adottato per la network interface master/slave}

Riprendiamo l'architettura delle network interface initiator e target già presentata nel Capitolo~\ref{cap:capitolo3}. 
\begin{figure}[!htbp]
	\centering
	\subfigure[\label{fig:ni-initiator-d}]{\includegraphics[scale = 0.5]{figure/ni-slave}}
	\subfigure[\label{fig:ni-target-d}]{\includegraphics[scale = 0.5]{figure/ni-master}}
	\caption{Schema a blocchi di NI initiator (~\ref{fig:ni-initiator-d}) e NI target (~\ref{fig:ni-target-d})}
	\label{fig:ni-xpipes}
\end{figure}
Analizziamo la gestione di una transazione, da parte della NI initiator, a partire dall'arrivo di un comando OCP di read: 
\begin{enumerate}
	\item il comando OCP viene campionato dalla NI sul fronte positivo del clock;
	\item il sotto blocco \emph{ni\_request} crea il pacchetto corrispondente e lo divide nelle flow control unit (flit);
	\item la \emph{ni\_request} comunica alla \emph{ni\_response}, sul canale di response, tramite il segnale \emph{trans\_id}, il tipo di transazione in corso;
	\item essendo la transazione una read, la network interface deve attendere il dato dalla NI target. Il segnale \emph{full\_response} viene utilizzato da \emph{ni\_response} per segnalare che la coda contenente il campo \emph{trans\_id} è piena e non possono più essere accettate transazioni che prevedano una risposta da parte dell'IP core slave.
\end{enumerate}
Gestione del comando di read da parte della NI target:
\begin{enumerate}
	\item i flit in arrivo dalla network on chip vengono raccolti dalla \emph{ni\_receive} e utilizzati per ricomporre il messaggio, che viene poi riconvertito in comando OCP;
	\item \emph{ni\_receive} comunica al sotto blocco \emph{ni\_resend}, sul canale di response, il tipo di comando ricevuto tramite il segnale \emph{MCmd\_resp}, la NI sorgente della comunicazione tramite il segnale \emph{source\_msg}, il numero di \emph{SData} che devono essere campionati (nel caso di burst read) tramite il segnale \emph{num\_request\_made};  
	\item la \emph{ni\_resend} campiona gli \emph{SData} e costruisce i flit di risposta utilizzando le informazioni ottenute da \emph{ni\_receive}, come il tipo di comando, l'indirizzo del sorgente, ecc\ldots
\end{enumerate}
Da quanto detto, è evidente come la NI target non permetta agli IP core ad essa collegati di iniziare nuove transazioni, poiché non fornisce a questi ultimi tutti i segnali OCP necessari ma solo un sotto insieme di essi, che al più consente l'invio di risposte che poi vengono convertite in flit utilizzando le informazioni ottenute dal modulo \emph{ni\_receive}.\\
Per poter far si che tutti i moduli del simulatore Cellsim possano iniziare nuove transazioni, la soluzione che è stata adottata ha visto la sostituzione del sotto blocco \emph{ni\_resend} della NI target con il modulo \emph{ni\_request}. Lo schema a blocchi risultante è mostrato in Figura~\ref{fig:NI-master-slave}.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.8]{figure/ni-master-slave}
	\caption{Schema a blocchi della network interface che offre funzionalità sia master che slave}
	\label{fig:NI-master-slave}
\end{figure}
I segnali di comunicazione, tra il canale di request e quello di response, che non hanno più alcun senso sono stati tratteggiati in rosso, mentre il segnale \emph{enable\_new\_message} è stato posto a uno logico. Ciò significa che il modulo \emph{ni\_receive} può sempre ricevere nuove transazioni senza aspettare che la precedente sia terminata (la fase di response è stata eliminata). Tutti i segnali OCP in uscita dal modulo \emph{ni\_receive} sono stati rinominati aggiungendo il suffisso \emph{\_recv}, in modo da distinguerli da quelli in ingresso al modulo \emph{ni\_request}. Infine è stato esportato il segnale \emph{MSource} corrispondente a \emph{SOURCE}, che prima veniva assegnato in fase di istanziazione della NoC e che ora viene utilizzato per il trasferimento del puntatore al memory access in esame da un modulo di Cellsim all'altro. 
%Le NI initiator si contraddistingue da quella target per il fatto di porter elaborare comandi OCP tramite il sottoblocco ni\_request. Per questo motivo, la realizzazione di una NI che sia contemporaneamente master e slave può essere eseguita sostituendo, all'interno della NI target, il sotto modulo ni\_resend con ni\_request. ni\_resend infatti non permette agli IP core collegati di avviare, tramite comando OCP, una nuova transazione che non sia una risposta a un precedente comando. 

\subsection{Implementazione SystemC della NoC} 
Le modifiche apportate allo schematico della NI target si sono tradotte in modifiche del codice SystemC descrittivo della network on chip. I file SystemC che contengono il codice della network interface master sono \emph{ni\_target.h} e \emph{ni\_target.cpp}. Il file di header definisce porte, canali del modulo e processi, mentre il file con estensione \emph{cpp} contiene l'implementazione di tali processi. Come detto, l'unica variazione rispetto all'originale consiste nell'eliminazione di alcune porte. Il codice corrispondente alla NI target è contenuto nel file \emph{ni\_target\_my.h}. Da esso sono state rimosse tutte le righe di codice che fanno riferimento a segnali che non sono più utilizzati; inoltre, il segnale \texttt{enable\_new\_message} è stato posto a uno logico all'interno del modulo stesso. 

\subsection{$\times$pipes compiler}
$\times$pipes viene fornito con un compilatore, chiamato $\times$pipescompiler, che permette, a partire da una descrizione testuale della topologia della network on chip, di istanziare i componenti della libreria (network interface, switch e link) e di collegarli in modo tale da ottenere la configurazione topologica desiderata. Inoltre è anche possibile specificare altri parametri, come ad esempio la dimensione dei buffer degli switch e delle network interface.\\
Le modifiche architetturali apportate alla network on chip, che prevedono ora l'utilizzo di una sola network interface, rappresentante contemporaneamente master e slave, hanno reso necessaria anche una revisione del compilatore in modo che questo fosse in grado di generare la topologia specificata dal progettista a partire dall'unica tipologia di NI disponibile. \\
$\times$pipes compiler prende come ingresso il file di descrizione testuale della network on chip e genera i seguenti file di output:
\begin{itemize}
	\item[$\circ$] \emph{xpipes\_interconnect.h}: contine le istanze di NI, switch, link e le loro interconnessioni;
	\item[$\circ$] \emph{xpipes\_interconnect.cpp}: include i file cpp dei blocchi elementari costituenti network interface e switch;
	\item[$\circ$] \emph{xpipes\_topology\_parameters.h}: contiene il parametro ROUTEWD che specifica la lunghezza, in numero di bit, del campo PATH presente nei flit di header del pacchetto;
	\item[$\circ$] \emph{routing\_target.h}: contiene l'istanza delle lookup table all'interno delle quali sono memorizzate le route che i flit devono percorrere;
	\item[$\circ$] \emph{routing\_target.cpp}: associa a ogni pacchetto, tramite il segnale \emph{lut\_path} che va in ingresso al modulo \emph{ni\_request}, la sequenza di bit corrispondente alle porte degli switch che devono essere attraversate per giungere a destinazione.
\end{itemize}
I cambiamenti apportati si ripercuotono su \emph{xpipes\_interconnect.h} e su \emph{routing\_target.cpp}. Tutto il codice relativo a xpipescompiler è contenuto nel file \emph{xcompiler.cpp}.
%-----------------------------------------------------------------------------------------------------------------
\section{Realizzazione del modulo wrapper e integrazione dei due ambienti di sviluppo}
In questo paragrafo vengono descritti in dettaglio i passi che sono stati seguiti al fine di rendere operativo il codice SystemC di $\times$pipes all'interno del simulatore Cellsim. Il processo di integrazione è stato raggiunto attraverso tre punti principali:
%In questo paragrafo viene descritta la realizzazione del modulo wrapper SystemC-UNISIM che permette di integrare la network on chip $\times$pipes all'interno del simulatore Cellsim. Vengono inoltre descritte le operazioni compiute per rendere funzionante il sistema.	Esse comprendono la modifica del makefile originale del simulatore, in modo da aggiungere le librerie SystemC necessarie e i file cpp della NoC e il ritocco della funzione \texttt{main()} all'interno del file \emph{cellsim.uni.cxx}.
\begin{enumerate}
	\item Inserimento delle istruzioni necessarie alla chiamata dello scheduler SystemC all'interno del \emph{main()} del simulatore (contenuto nel file \emph{cellsim.uni.cxx}).
	\item Integrazione dei sorgenti $\times$pipes e delle librerie SystemC all'interno del Makefile di Cellsim (contenuto nel path \emph{./cellsim-0.9\_noc/src/modules}).
	\item Realizzazione del modulo wrapper (involucro), all'interno del quale è contenuta l'istanza di \emph{xpipes\_interconnect} e che permette l'interoperabilità del codice corrispondente ai due diversi ambienti di sviluppo, SystemC e UNISIM.
\end{enumerate}

\subsection{Integrazione SystemC - UNISIM}
Sono di seguito descritti i primi due passi del processo di integrazione su menzionato. Essi hanno permesso di rendere operativo, all'interno del simulatore Cellsim, il codice SystemC della NoC $\times$pipes. Il primo dei due ha previsto l'inserimento, nella funzione \emph{main()} del simulatore, dell'istruzione \emph{sc\_start()} per il passaggio del controllo, durante la simulazione, allo scheduler SystemC. Il secondo ha richiesto invece la modifica del Makefile, per l'automatizzazione del processo di compilazione del codice (SystemC e UNISIM) e la generazione del binario.

\subsubsection{Il file cellsim.uni.cxx}
Durante la simulazione, il passaggio del controllo allo scheduler UNISIM viene ottenuto tramite chiamata alla funzione \emph{fsc\_phase()}, come riportato nel \emph{main()} mostrato nel Listato~\ref{lst:cellsim-main}. In particolare, è possibile notare come questa sia invocata due volte all'interno del ciclo \emph{while}, una volta per il fronte ascendente del clock e una volta per il fronte discendente.\\
Per fare in modo che anche lo scheduler SystemC possa prendere il controllo della simulazione, sono state inserite, tra le due \emph{fsc\_phase()}, due chiamate a \emph{sc\_start()}. L'intervallo di tempo durante il quale il controllo è conferito allo scheduler SystemC deve essere limitato, in modo da poter ritornare a UNISIM per il proseguo della simulazione. Per questo motivo, all'interno di \emph{sc\_start()}, è stato specificato un tempo di esecuzione pari a 1 nanosecondo (valore di default per l'unità di tempo).
%All'interno della funzione \emph{main()} (Listato~\ref{lst:cellsim-main}), il passaggio del controllo allo scheduler UNISIM viene gestito dal metodo \emph{fsc\_phase()}.
\begin{lstlisting}[caption=Funzione main() all'interno del file cellsim.uni.cxx, label=lst:cellsim-main]
...
int main(int argc, char* argv[])
{
#include "prolog.cxx"
	command_line.parse(argc,argv);
	GeneratedSimulator s;
	unisim_port::check_connections();
#include "cellsim.uni.inc.init.cxx"
	signal(SIGINT,GeneratedSimulator::at_ctrlc);
	signal(SIGTSTP,GeneratedSimulator::at_ctrlz);
//#include "before_simloop.cxx" the comment is removed if the file exists
	while(!unisim_terminated)
	{
		fsc_phase();
		sc_start(1);
		fsc_phase();
		sc_start(1);
#include "cellsim.uni.inc.eoc.cxx"
		if(s._unknown_display) unisim_port::
			check_knowness(s.stream_knowness(),s._unknown_fatal);
	}
	sc_stop();
	//#include "epilog.cxx" the comment is removed if the file exists
	return 0;
} //main()
\end{lstlisting}
Finché l'esperimento non termina, il controllo della simulazione viene passato da UNISIM a SystemC secondo lo schema riportato in Figura~\ref{fig:exec-flow}. In figura sono rappresentate le fasi di \emph{start\_of\_cycle} e di \emph{end\_of\_cycle}, evidenziate in rosso e in blu, rispettivamente, alternate da chiamate dello scheduler SystemC, evidenziate in verde.\\
Poiché Cellsim utilizza un solo dominio di clock anche per $\times$pipes ne è stato usato solo uno (\emph{clock\_div} uguale a uno). I segnali di clock per la NoC, \emph{OCP\_clock} e \emph{xpipes\_clock}, vengono prodotti dal wrapper. Il fronte positivo viene generato allo \emph{start\_of\_cycle}, il fronte negativo all'\emph{end\_of\_cycle}. In questo modo le NI campionano il fronte positivo solo dopo lo \emph{start\_of\_cycle}. Di questo è stato tenuto conto nella realizzazione del wrapper, in particolare nella generazione dei segnali di accept da inviare alla NI durante la ricezione di una transazione.
%All'interno del while viene richiamata ciclicamente, finché la simulazione non termina e due volte per ciclo, la funzione \emph{fsc\_phase()}, una volta per il fronte di clock ascendente e una volta per il fronte discendente. Tra queste due sono state inserite le chiamate allo scheduler SystemC (\emph{sc\_start(1)}).\\
%A questo punto dovrebbe anche essere più chiara la funzione delle variabili \emph{SDataAccept\_next} e \emph{SCmdAccept\_next}. Allo \emph{start\_of\_cycle} vengono generati i segnali di accept per dato e comando, che sono stati ricevuti dalla network interface al fronte positivo del clock. Prima che la NoC possa campionare questi segnali, la fase di \emph{start\_of\_cycle} deve essere terminata e il controllo deve passare allo scheduler SystemC. Tramite queste due variabili è possibile rimandare alla successiva fase di \emph{end\_of\_cycle} l'operazione di reset dei segnali di accept, ovvero dopo che questi sono stati campionati dalla NoC.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.6]{figure/exec-flow}
	\caption{Flusso di esecuzione durante la simulazione}
	\label{fig:exec-flow}
\end{figure}

\subsubsection{Makefile Cellsim}
Un makefile è un particolare tipo di Linux file che, insieme all'utility make, permette di automatizzare il processo di conversione del codice sorgente di un programma in codice oggetto, unendo e poi linkando il codice oggetto in eseguibili o librerie. Esso gestisce le dipendenze e contiene gli script di compilazione da passare alla shell.\\
Nel Listato~\ref{lst:makefile} è riportato un esempio di makefile che compila un sorgente chiamato \emph{helloworld.cpp} usando g++, un compilatore C++. Il tag PHONY è un tecnicismo che dice al make che un particolare nome di target non produce alcun file. I simboli \$@ e \$< sono chiamati variabili automatiche e rappresentano il nome del target. Di queste ve ne sono altre.
\begin{lstlisting}[caption=Semplice esempio di makefile, label=lst:makefile]
helloworld: helloworld.o
	g++ -o $@ $<
 
helloworld.o: helloworld.cpp
	g++ -c -o $@ $<
 
.PHONY: clean
clean:
	-rm -f helloworld helloworld.o
\end{lstlisting}
Cellsim, in accordo con la metodologia descritta, fornisce un makefile\footnote{Il Makefile in questione è contenuto nella cartella \emph{./cellsim-0.9/src/modules/}} per la compilazione di tutti i sorgenti del progetto e la generazione dell'eseguibile. All'interno di esso sono stati aggiunti i file relativi alla NoC e le librerie SystemC corrispondenti, utilizzati dal compilatore per la generazione del binario. Di seguito sono riportate le righe aggiuntive impiegate a tale scopo:
\begin{lstlisting}[caption=Makefile Cellsim, label=lst:cellsim-makefile]
# CellSim sources
nodist_cellsim_SOURCES = \
	...
	/home/gcongiu/NetworkOnChip_my_advanced/xpipes_interconnect.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/ni_target_my.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/switch.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/allocator.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/ni_buffer.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/out_buffer.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/routing_target.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/advanced_ni_request.cpp \
	/home/gcongiu/NetworkOnChip_my_advanced/advanced_ni_receive.cpp
...
# CellSim flags
cellsim_CXXFLAGS = \
	...
	-I/home/gcongiu/systemc-2.2.0/include \
	-DXPIPES_SIMULATION \
	$(DBGFLAGS)

cellsim_LDADD = \
	...
	-lsystemc \
	-lm

cellsim_LDFLAGS = \
	...
	-L/home/gcongiu/systemc-2.2.0/lib-linux \
	-L`$(UNIC) -l`
...
\end{lstlisting}
Nella sezione \texttt{Cellsim sources} sono stati aggiunti tutti i sorgenti \emph{cpp} relativi ai moduli SystemC di $\times$pipes; nella sezione \emph{Cellsim flags} sono stati aggiunti: il path contenente l'header file \emph{systemc.h}, un define, \emph{-DXPIPES\_SIMULATION}, per specificare al preprocessore C++ le parti di codice $\times$pipes da compilare, relative alla sola simulazione (non dobbiamo fare alcuna sintesi del progetto) e infine, le librerie SystemC da utilizzare per la compilazione. 


%------------------------------------------------------------------------------------------------------------------
\section{Modulo wrapper}
Come visto nel Capitolo~\ref{cap:capitolo2}, una delle caratteristiche chiave di UNISIM è la sua grande capacità di interoperare con altri ambienti di sviluppo. L'utilizzo di tale proprietà prevede l'integrazione, all'interno di appositi moduli software chiamati \emph{WRAPPER} (involucro), del codice descrittivo del blocco hardware in esame, sviluppato, ad esempio, in linguaggio SystemC o in uno degli altri linguaggi supportati.\\
La realizzazione del modulo wrapper è stata una delle parti principali del lavoro di tesi. Questa ha richieto lo studio approfondito delle network interface $\times$pipes in modo tale da poter realizzare funzioni specifiche per lo scambio efficente di informazioni e la gestione delle transazioni. In particolare, le NI utilizzano un protocollo di comunicazione standardizzato, denominato OCP, per lo scambio di dati e comandi tra gli IP core connessi alla rete. Cellsim adopera invece, a tale scopo, la classe memory access; tutte le informazioni, dai comandi ai dati, sono inserite al loro interno e inviate, tramite il rete di interconnessione, agli altri moduli del simulatore. Perciò, compito del wrapper è quello di convertire i memory access in comandi OCP per le network interface, che a loro volta creano i flit da inviare all'interno della network on chip. Quando questi ultimi raggiungono la NI target, i comandi OCP devono essere riconvertiti in memory access. In Figura~\ref{fig:wrapper} è riportata una rappresentazione schematica del modulo wrapper.\\
Nelle pagine che seguono, vengono descritte, in modo dettagliato, tutte le funzionalità aggiuntive, per lo scambio di informazioni e la gestione delle transazioni, che sono state integrate all'interno del wrapper.
%La realizzazione del modulo wrapper ha previsto l'inserimento, all'interno del codice del k-bus, del file \emph{xpipes\_interconnect.h} generato da $\times$pipes compiler (Figura~\ref{fig:wrapper}). Il k-bus è stato, anche in questo caso, utilizzato per fornire le funzionalità di sincronizzazione con gli altri moduli del simulatore e per l'implementazione dell'algoritmo di snooping per il controllo della cache coherency, che non è supportato dalla versione di $\times$pipes adottata.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.55]{figure/wrapper}
	\caption{Modulo wrapper con al suo interno istanziato il file xpipes\_interconnect.h, contenente a sua volta le istanze dei componenti della NoC}
	\label{fig:wrapper}
\end{figure}

\subsection{Comunicazione Cellsim - $\times$pipes}
Il protocollo di comunicazione impiegato tra i due simulatori, Cellsim e $\times$pipes, è definito dalle specifiche dello standard OCP. Ciò significa che il modulo wrapper deve generare in modo adeguato, tutti i segnali OCP da inviare alle network interface e necessari per l'instaurazione delle transazioni.\\
Cellsim prevede due tipi di memory access per lo scambio di dati e istruzioni (Capitolo~\ref{cap:capitolo2}):
\begin{itemize}
	\item[$\circ$] \textbf{memory access load}: utilizzati per richieste di lettura
	\item[$\circ$] \textbf{memory access store}: utilizzati per le richieste di scrittura
\end{itemize}
Sono inoltre disponibili due istruzioni supplementari, \textbf{atomic load} e \textbf{atomic store}, per la gestione della cache coherency. Quest'ultima viene lasciata a Cellsim (al k-bus che fornisce la base per il wrapper) in quanto la versione di $\times$pipes utilizzata non supporta i comandi corrispondenti.\\
Le transazioni OCP scelte per la conversione delle richieste di load e store sono:
\begin{itemize}
	\item[$\circ$] \textbf{burst read}
	\item[$\circ$] \textbf{burst write} 
\end{itemize}
L'estensione burst è stata scelta per ridurre la latenza del pacchetto corrispondente al memory access, all'interno della rete. Infatti, ogniuno di questi è suddiviso in flit di header e payload. Solo questi ultimi trasportano informazione utile (dati), mentre l'header contiene informazioni aggiuntive per il routing. Tramite l'estensione burst è possibile mandare un solo header per ogni transazione riducendo la latenza complessiva del messaggio.\\

\subsubsection{Invio di una richiesta di load}
L'invio di un memory access load viene effettuato mediante un comando OCP read con estensione burst. Le informazioni associate a una richiesta di tipo load sono:
\begin{itemize}
	\item[$\circ$] \emph{\_state}: contiene il tipo di transazione (load, store, ecc\ldots);
	\item[$\circ$] \emph{\_size}: specifica la dimensione del dato da leggere;
	\item[$\circ$] \emph{\_source}: fornisce l'indirizzo della locazione di memoria da inserire nel campo \emph{\_target} del memory access store di risposta;
	\item[$\circ$] \emph{\_target}: rappresenta l'indirizzo della locazione di memoria dalla quale leggere (local store o memoria centrale).
\end{itemize}
Di queste, solo \emph{\_state}, \emph{\_size} e \emph{\_target} sono necessarie per la conversione. \emph{\_state} viene utilizzato per selezionare il tipo di comando OCP corrispondente; \emph{\_size} serve a specificare il numero di byte che devono essere letti dalla locazione di memoria indicata da \emph{\_target}; quest ultimo infine è anche utilizzato da \emph{routing\_target} per il calcolo della route da includere nel campo \emph{PATH} dei flit di head (informazione estratta dal segnale \emph{lut\_path}). \emph{\_source} è superfluo in quanto, l'informazione utile trasferita dalla rete è contenuta nel puntatore al memory access, che come precedentemente enfatizzato, viene trasferito tramite il segnale \emph{MSource} della network interface e inserito nel campo \emph{SOURCE} dei flit di head. 
%Di queste, vengono utilizzate solamente \emph{\_state}, per selezionare il tipo di comando OCP corretto (burst read) e \emph{\_target}, che viene invece passato come ingresso a \emph{routing\_target} per il calcolo della route all'interno della NoC (informazione contenuta in \emph{lut\_path}). Le altre informazioni sono superflue in quanto, come già precedentemente enfatizzato, ad essere trasferiti tra un IP core e l'altro sono i puntatori ai memory access. \\
La Figura~\ref{fig:send-load} riporta una rappresentazione schematica dell'avvio di una transazione burst read da parte del wrapper; la simbologia associata ai colori è la stessa utilizzata in Figura~\ref{fig:exec-flow}. La transazione è gestita tramite le seguenti funzioni:
\begin{itemize}
	\item[$\circ$] \emph{convertFromMemoryAccessLdToOcp}: è attiva durante la fase di \emph{end\_of\_cycle} e si occupa di settare i segnali OCP della network interface ai valori riportati in Tabella~\ref{tab:load-table};
\begin{table}[!htbp]
	\centering
	\begin{tabular}{|c|c|}
	\hline OCP signal & Value \\ 
	\hline MCmd & 2 \\ 
	 MAddr & \_target \\ 
	 MBurstLenght & \_size \\ 
	 MBurstPrecise & true \\ 
	 MBurstSeq & 5 \\
	 MBurstSingleReq & true \\
	 MSource & memoryaccess \\
	 MReqLast & true \\
	 MByteEn & - \\
	 MDataLast & - \\
	 MDataValid & - \\
	 MData & - \\
	\hline
	\end{tabular}
	\caption{Segnali OCP generati dalla funzione \emph{convertFromMemoryAccessLdToOcp}}
	\label{tab:load-table}
\end{table} 
	\item[$\circ$] \emph{manageLoadRequest}: è attiva nella fase di \emph{start\_of\_cycle} e si occupa di controllare se il comando OCP è stato accettato dalla network interface, in questo caso elimina il memory access dall'\emph{\_inputLdBuffers}.
\end{itemize}
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/send-load}
	\caption{Fasi di invio di una richiesta di load}
	\label{fig:send-load}
\end{figure}
La gestione della transazione da parte del wrapper in Figura~\ref{fig:send-load}, segue il seguente schema:
\begin{enumerate}
	\item All'\emph{end\_of\_cycle} la funzione \emph{convertFromMemoryAccessLdToOcp} genera i comandi OCP  corrispondenti al memory access load, presente nel buffer di ingresso del wrapper, da inviare alla network interface $\times$pipes. Tale funzione setta anche un flag, denominato \emph{semaphore}, che riserva l'uso di quest'ultima per tutta la durata della transazione (finché il comando di read non viene accettato);
	\item Il controllo passa allo scheduler SystemC che si occupa di risvegliare i processi, del modulo ni\_request, che gestiscono le richieste OCP e generano i segnali di risposta per il wrapper;
	\item Il controllo torna allo scheduler UNISIM. I segnali OCP precedentemente generati, vengono valutati dalla funzione \emph{manageLoadRequest} durante la successiva fase di \emph{start\_of\_cycle}. Se il comando di read è stato accettato dalla NI, la funzione rilascia il flag \emph{semaphore} e cancella il memory access load dal buffer di ingresso del wrapper, in caso contrario torna alla passo 1.
\end{enumerate}
Il flag \emph{semaphore} è stato introdotto per disciplinare l'accesso alle network interface da parte delle funzioni che gestiscono la conversione dei memory access in transazioni OCP. Nel caso in cui un comando OCP non venisse accettato immediatamente dalla NI corrispondente, la transazione protrebbe protrarsi per diversi cicli, finché non viene generato il segnale OCP di accept. Se durante questo intervallo di tempo arriva in ingresso al wrapper un memory access store, la NI non può essere utilizzata per inviarlo.

\subsubsection{Invio di una richiesta di store}
L'invio di un memory access store viene effettuato mediante un comando OCP write con estensione burst. Le informazioni associate a una richiesta di tipo store sono le stesse di una richiesta di load, in aggiunta è presente anche il dato da trasferire, contenuto nel campo \emph{\_data} del memory access. Il wrapper in questo caso si deve occupare della serializzazione di quest ultimo per il trasferimento alla network interface. La \emph{\_size} viene utilizzata, insieme a \emph{MDATAWD}, per il calcolo del numero di burst della write. La Figura~\ref{fig:send-store} riporta una rappresentazione schematica dell'avvio di una transazione burst write; la simbologia associata ai colori è la stessa utilizzata in precedenza. La transazione è gestita tramite le seguenti funzioni:
\begin{itemize}
	\item[$\circ$] \emph{convertFromMemoryAccessStToOcp}: è attiva durante la fase di \emph{end\_of\_cycle} e si occupa di settare i segnali OCP della network interface ai valori riportati in Tabella~\ref{tab:store-table} (i valori contrasegnati con una x variano durante la transazione);
	\item[$\circ$] \emph{manageStoreRequest}: è attiva durante lo \emph{start\_of\_cycle} e si occupa di aggiornare le variabili del wrapper utilizzate per la gestione della transazione.
\end{itemize}
\begin{table}[!htbp]
	\centering
	\begin{tabular}{|c|c|}
	\hline OCP signal & Value\\ 
	\hline MCmd & 1\\ 
	 MAddr & \_target\\ 
	 MBurstLenght & wordToTransfer\\ 
	 MBurstPrecise & true\\ 
	 MBurstSeq & 5\\
	 MBurstSingleReq & true\\
	 MSource & memoryaccess\\
	 MReqLast & true\\
	 MByteEn &  x\\
	 MDataLast & x \\
	 MDataValid & true\\
	 MData & 0 \\
	\hline
	\end{tabular}
	\caption{Segnali OCP generati dalla funzione \emph{convertFromMemoryAccessStToOcp}}
	\label{tab:store-table}
\end{table} 
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/send-store}
	\caption{Fasi di invio di una richiesta di store}
	\label{fig:send-store}
\end{figure}
La gestione di una burst write da parte del wrapper viene fatta utilizzando le seguenti variabili:
\begin{itemize}
	\item[$\circ$] \emph{semaphore}: anche in questo caso, serve a disciplinare l'accesso alle network interface $\times$pipes da parte delle funzioni di conversione dei memory access definite dal wrapper;
	\item[$\circ$] \emph{wordToTransfer}: rappresenta il numero di burst associati alla write. Tale quantità è un numero ottenuto dividendo il campo \emph{\_size} del memory access per il campo \emph{MDATAWD} della network interface, il risultato dell'operazione viene arrotondato all'intero più grande. In quest ultimo caso, il blocco di dati finale ha dimensione inferiore a \emph{MDATAWD}, questo è tenuto in conto tramite il segnale \emph{MByteEn};
	\item[$\circ$] \emph{byteTxNumber}: memorizza il numero di byte accettati dalla network interface.
\end{itemize}
Le fasi di elaborazione della richiesta di write sono rappresentate in Figura~\ref{fig:send-store}, numerate da 1 a 3:
\begin{enumerate}
	\item la funzione \emph{convertFromMemoryAccessStToOcp} si occupa, durante l'\emph{end\_of}\-\emph{\_cycle}, della generazione dei segnali OCP per la network interface, gestita tramite l'ausilio delle variabili \emph{wordToTransfer} e \emph{byteTxNumber}. In questa fase il flag \emph{semaphore} viene settato a 1;
	\item il controllo della simulazione passa allo scheduler SystemC. A questo punto la network interface campiona i segnali provenienti dal wrapper e genera quelli di risposta;
	\item durante lo \emph{start\_of\_cycle} i segnali provenienti dalla NI vengono valutati. Se il dato è stato accettato, la variabile \emph{byteTxNumber} viene incrementata del numero di byte corrispondente; questa viene utilizzata da \emph{convertFromMemoryAccessStToOcp} per tenere conto del numero di dati che ancora restano da inviare. Se l'ultimo blocco di dati è stato inviato con successo, la transazione termina e il flag \emph{semaphore} viene riportato a 0 (idle), in caso contrario torna alla fase 1 per l'invio di un nuovo dato.
\end{enumerate}

\subsubsection{Ricezione di una richiesta di read}
La gestione di una transazione di read proveniente dalla network interface viene gestita dal wrapper, come mostrato in Figura~\ref{fig:recv-load}, tramite le seguenti fasi:
\begin{enumerate}
	\item il blocco ni\_receive della network interface riceve i pacchetti dalla NoC e genera i segnali OCP per il wrapper;
	\item durante l'\emph{end\_of\_cycle}, se il buffer di uscita corrispondente alla porta in questione è libero, i segnali OCP provenienti dalla network interface vengono elaborati da \emph{convertFromOcpToMemoryAccessLd}. In particolare, questa estrae dal segnale \emph{MSource\_recv} il puntatore a memory access, lo trasferisce nell'\emph{outputBuffers} del wrapper e genera i segnali di accept per la NI. Nel caso in cui invece il buffer non fosse vuoto, i segnali OCP non vengono accettati e si passa al ciclo di clock successivo.
	\item se la ricezione è andata a buon fine, ovvero se il buffer di uscita era disponibile a ricevere il memory access in arrivo dalla NoC, la funzione \emph{manageRecvLoadRequest} allo \emph{start\_of\_cycle} avverte, tramite il segnale \emph{SCmdAccept\_next}, che su \emph{SCmdAccept} è presente un valore valido che deve essere campionato dalla NI durante il fronte del clock positivo (rappresentata in Figura~\ref{fig:exec-flow} dalla fase verde successiva a quella rossa), in questo modo \emph{SCmdAccept} viene risettato a false all'\emph{end\_of\_cycle};
	\item il controllo torna allo scheduler SystemC. In questa fase il modulo ni\_receive campiona l'accept proveniente dal wrapper e la transazione termina.
\end{enumerate}
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/recv-load}
	\caption{Fasi di ricezione di una richiesta di load}
	\label{fig:recv-load}
\end{figure}

\subsubsection{Ricezione di una richiesta di write}
La ricezione di una transazione di write viene gestita in modo differente rispetto a quella di una read. In questo caso, infatti, la sono presenti anche dei dati che possono richiedere più cicli di clock per essere raccolti. La Figura~\ref{fig:recv-store} illustra le fasi utilizzate nella gestione di una transazione write proveniente dalla network on chip. 
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/recv-store}
	\caption{Fasi di ricezione di una richiesta di store}
	\label{fig:recv-store}
\end{figure}

Rispetto al caso di trasmissione, nel quale erano necessarie variabili ausiliarie per la gestione dell'operazione, ora è la network interface che si occupa di segnalare al wrapper quando la transazione ha termine, tramite il segnale OCP \emph{MDataLast}. \\
Le fasi coinvolte nella ricezione di una write sono di seguito riportate:
\begin{enumerate}
	\item il modulo ni\_receive della network interface genera i segnali OCP per il modulo wrapper;
	\item durante l'\emph{end\_of\_cycle} la funzione \emph{convertFromOcpToMemoryAccessSt} raccoglie ed elabora i segnali OCP provenienti dalla NI, in particolare estrae il puntatore a memory access da \emph{MSource\_recv} e genera gli accept per \emph{ni\_receive};
	\item allo \emph{start\_of\_cycle} la funzione \emph{manageRecvStoreRequest} genera i segnali \emph{SCmdAccept\_next} e \emph{SDataAccept\_next} che vengono usati nella successiva fase di \emph{end\_of\_cycle} per resettare \emph{SCmdAccept} e \emph{SDataAccept}, quindi solo dopo che il controllo è passato allo scheduler SystemC per il campionamento di questi ultimi da parte di ni\_receive;
	\item il controllo della simulazione torna allo scheduler SystemC e i segnali di accept vengono campionati dalla network interface. Se \emph{MDataLast} è alto, la transazione termina e il puntatore a memory access viene trasferito da \emph{convertFromOcpToMemoryAccessSt} nell'\emph{outputBuffers} del wrapper, in caso contrario si torna al passo 1 per la ricezione del prossimo blocco di dati.
\end{enumerate}


Tutto il codice del modulo wrapper è contenuto all'interno del file \emph{EIB\_wrapper}\-\emph{\_noc.sim}, nel path \emph{./cellsim-0.9\_noc/src/modules/processor}.

\section{Parametri di configurazione adottati per la network on chip}
In questo paragrafo vengono approfonditi i concetti legati ai parametri di configurazione scelti per la network on chip utilizzata negli esperimenti. Questi comprendono configurazione topologica, algoritmo di routing, meccanismi di flow control e dimensione dei flit.

\subsection{Topologia}
La network on chip è costituita da un certo numero di nodi condivisi (switch) e di canali utilizzati per connetterli, con topologia si fa riferimento proprio all'organizzazione che nodi e canali hanno all'interno della rete. Nel lavoro di tesi sono state testate le topologie più frequetemente incontrate in letteratura:
\begin{itemize}
	\item[$\circ$] \textbf{Crossbar}
	\item[$\circ$] \textbf{Mesh}
	\item[$\circ$] \textbf{Torus}
	\item[$\circ$] \textbf{Spidergon}
\end{itemize}
Queste vengono illustrate con maggior dettaglio nel Capitolo~\ref{cap:capitolo6}.

\subsection{Algoritmo di routing}
L'algoritmo di routing che si è scelto di adottare nell'ambito di $\times$pipes è il source routing di tipo deterministico. Il percorso che i pacchetti devono seguire nella rete per giungere a destinazione è stabilito al nodo sorgente. Le informazioni necessarie per fare giungere a destinazione i pacchetti sono contenute in una tabella di memoria (\emph{lookup table}) presente su ogni network interface. Il percorso (\emph{path}) che questi devono seguire è determinato staticamente in base all'indirizzo del destinatario del messaggio: l'algoritmo di routing fa uso esclusivamente di questa informazione senza tenere conto dello stato attuale della rete. Dal momento che la trasmissione dell'header implica l'impiego di parte della banda di rete disponibile, è meglio che la sua dimensione sia ridotta all'essenziale. Un metodo di source routing che permette di venire incontro a questa esigenze è lo \emph{street-sign-routing}. Tale metodo consiste nel fornire ad ogni switch intermedio che il pacchetto si trova a dovere attraversare lungo il suo percorso un'informazione riguardo alla direzione di uscita dallo switch che il pacchetto deve percorrere. Questa tecnica di instradamento comporta che le informazioni di routing siano inserite nell'header rispettando l'ordine con il quale gli switch sono attraversati.

\subsection{Politica di flow control}
I meccanismi di flow control, nelle architetture di network on chip, reppresentano un aspetto critico per la rapida propagazione dei pacchetti attraverso la rete e per l'utilizzo efficiente delle sue risorse. Gestione e allocazione dei buffer sono aspetti fondamentali nella scelta dello schema di flow control. Per l'implementazione di $\times$pipes adottata è stato scelto un algoritmo denominato \emph{STALL/GO} che viene di seguito descritto.\\

\emph{STALL/GO} è un algoritmo molto semplice basato su un protocollo di flow control ON/OFF~\cite{flow-control} (Figura~\ref{fig:stall-go}).
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/stall-go}
	\caption{Implementazione del protocollo STALL/GO}
	\label{fig:stall-go}
\end{figure}
Questo richiede solo due fili: uno diretto come il flusso dei flit e utilizzato per sondare la disponibilità della risorsa, uno che torna indietro e segnala la condizione di buffer pieno (STALL) o buffer vuoto (GO). \emph{STALL/GO} viene implementato tramite un buffering distribuito tra i link. Questo schema di controllo di flusso permette di minimizzare il consumo di potenza poiché ogni situazione di congestione viene eliminata semplicemente evitando di inviare il flit. Inoltre la logica richiesta alla sua implementazione è resa minima grazie alla semplicita del protocollo.

\subsection{Dimensione dei flit}
La dimensione dei flit è stata settata a un valore tale da permette il trasporto dell'intero dato, contenuto nel segnale OCP \emph{MData}, con un unico flit di payload. Per ragioni di praticità, la network on chip è stata configurata con un valore di \emph{MDATAWD} pari a 64-bit; di conseguenza si è scelta per i flit una dimensione di 84-bit, per tenere conto anche della presenza dei campi \emph{Byte Enables} e \emph{Control} nel payload (si veda Capitolo~\ref{cap:capitolo3}).\\
Poiché la banda richiesta alla NoC per lo scambio di transazioni tra una SPE e l'altra è doppia rispetto a quella disponibile per memoria e PPE, all'interno del wrapper è stato inserito un fattore moltiplicativo K da utilizzare per il calcolo del numero di trasferimenti associati a ogni store. Per una banda di 128-byte/ciclo, K è stato posto pari a 2, in modo da raddoppiare i 64-bit offerti nativamente. Questo stratagemma è assolutamente lecito in quanto il compito della NoC non è quello di trasportare dati veri e propri, ma solo di simularne il trasferimento in modo da permettere la quantificazione delle prestazioni. 