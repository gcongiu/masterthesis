\chapter{Il simulatore Cellsim}\label{cap:capitolo2}
In questo capitolo viene presentato il simulatore Cellsim\cite{Cellsim}, utilizzato nel presente lavoro di tesi per il testing delle infrastrutture di comunicazione EIB e XPIPES\cite{XPIPES}. Cellsim fornisce un ambiente di simulazione modulare per architetture multiprocessore di tipo eterogeneo. Attualmente, viene implementata la prima versione della Cell Broadband Engine Architecture (CBEA). L'infrastruttura di base, utilizzata per la descrizione e la connessione dei moduli del simulatore, è rappresentata dal framework di simulazione strutturale UNISIM\cite{Unisim}.\\
In modo da consentire una migliore comprensione del modello di simulazione, che verrà richiamato anche nei capitoli seguenti, il primo paragrafo è dedicato alla descrizione di tale infrastruttura. 

\section{Il framework UNISIM}

UNISIM è l'ambiente di sviluppo adottato da Cellsim per la defini\-zione dell'architettura del processore Cell e per la sua simulazione. Il framework è diviso in due parti: una sintassi per la descrizione e la costruzione dei blocchi elementari del sistema e un motore (engine) per l'esecuzione della simulazione\cite{Unisim-tutorial}. Come per altri ambienti di sviluppo,  Verilog o VHDL per citarne alcuni, l'approccio utilizzato da UNISIM è di tipo strutturale, il che significa che ogni progetto è composto da diversi blocchi elementari chiamati moduli, ciascuno dei quali ha una corrispondenza diretta con un blocco fisico. I simulatori di tipo strutturale sono spesso contrapposti a quelli di tipo monolitico, come ad esempio SimpleScalar, dove può risultare difficile, se non impossibile, estrarre alcune componenti hardware del progetto per poterle riusare o sostituire. Le ragioni di questo sono molteplici. Ad esempio, potrebbe non essere possibile isolare all'interno del codice una procedura che espleti una particolare funzionalità; il comportamento risulta essere distribuito. Inoltre, anche se si potesse individuare una procedura di questo tipo, questa potrebbe far riferimento a variabili globali, rendendo impossibile qualunque intervento di ritocco del codice. 
La proprietà chiave dei simulatori strutturali è quella di consentire una mappatura semplice dello schema a blocchi del progetto (hardware block diagram) nei corrispondenti moduli del simulatore. 
Da un approccio di questo tipo derivano diversi benefici:
\begin{itemize}
	\item[$\circ$] \textbf{Riuso}: essendo il modulo l'unità funzionale di base, è possibile estrarre e riusare parti di un progetto in modo estremamente semplice. Si può anche pensare di cambiare il tipo di architettura di un componente, come ad esempio quella della cache all'interno di un microprocessore. Questo perché le interfacce processore/cache e cache/memoria centrale sono sempre le stesse. 
	\item[$\circ$] \textbf{Mappatura dei blocchi hardware nei moduli del simulatore}: i simulatori strutturali permettono una mappatura intuitiva dei blocchi dell'architettura target nei moduli del simulatore, facilitando lo sviluppo del progetto; per la stessa ragione la simulazione strutturale migliora l'affidabilità e aumenta la fiducia nel modello di simulazione. 
	\item[$\circ$] \textbf{Sviluppo più semplice di progetti molto grossi}: la simulazione strutturale trae ispirazione dal paradigma dell'object orientation già noto nella software engeneering. La filosofia dell'object orientation è quella di puntare sulla decomposizione dei programmi, specialmente quelli di grosse dimensioni, in entità software più piccole, chiamate classi, che comunicano tra loro mediante interfacce. In questo modo l'architetto non si deve preoccupare del comportamento globale e si può concentrare su ogni singola classe indipendentemente dalle altre; egli dovrà solo fare in modo che ogni classe implementi la corretta interfaccia.
	\item[$\circ$] \textbf{Refactoring semplice}: con refactoring si fa riferimento alla pratica di aggiornamento e modifica del codice, in questo caso dei moduli che emulano il comportamento hardware. In un simulatore monolitico le varie parti del codice possono essere strettamente legate, per cui una modifica su una di queste può produrre comportamenti inaspettati da parte di altre. Ad esempio, se si usa una variabile per memorizzare il risultato di un'istruzione di branch e la si mette in un punto sbagliato del codice, l'effetto può essere equivalente a quello di propagare il segnale, risultato del branch, troppo in anticipo nella pipeline. Nei simulatori strutturali, grazie alla connessione esplicita fra i vari moduli, non è altrettanto semplice inciampare in questo tipo di problema. 
\end{itemize}
Le motivazioni che giustificano lo sviluppo di un nuovo ambiente di simulazione strutturale, quando ne esistono attualmente diversi, come ad esempio il SystemC, sono legate al completo raggiungimento degli obiettivi sopra elencati. In pratica, ambienti come SystemC adottano le proprietà definite, ma falliscono ampiamente nel conseguimento del riuso, dello scambio e del confronto tra i vari componenti del simulatore. Le ragioni sono le seguenti:
\begin{itemize}
	\item[$\circ$] \textbf{Il protocollo di comunicazione tra i moduli non è normalizzato}. Ambienti come SystemC forniscono una sintassi per scrivere le interfacce dei moduli, ma non specificano come questi debbano scambiarsi dati. Come risultato, due moduli sviluppati separatamente solitamente non possono comunicare.
	\item[$\circ$] \textbf{Non si presta attenzione al riuso del controllo}. I moduli descrivono la funzionalità dei blocchi hardware, ma generalmente la maggior parte del codice del simulatore corrisponde al \emph{controllo}. Il codice del controllo tipicamente descrive le interazioni tra i moduli. Come conseguenza, se uno di questi viene sostituito, il controllo deve essere riscritto, vanificando quasi completamente la capacità di riuso. 
\end{itemize}
Per superare tali limitazioni UNISIM fornisce quattro caratteristiche chiave aggiuntive:
\begin{itemize}
	\item[$\circ$] \textbf{Comunicazione normalizzata e riuso del controllo}. UNISIM risolve i sopra menzionati problemi definendo un protocollo di comunicazione, che caratterizza le interazioni tra i moduli e integrandolo nelle interfacce di comunicazione di ciascun modulo (chiamate \emph{porte}). Questo approccio prende il nome di \textbf{astrazione del controllo}.
	\item[$\circ$] \textbf{Interoperabilità}. UNISIM fornisce la possibilità di interoperare con simulatori esistenti. In pratica questa caratteristica è molto importante poiché i gruppi di ricerca che hanno investito molti sforzi nello sviluppo dei propri simulatori difficilmente li cambiano. UNISIM implementa l'interoperabilità dando la possibilità di avvolgere (tramite moduli \emph{wrappers}) i simulatori esistenti, in modo che questi possano comunicare con i moduli UNISIM. 
	\item[$\circ$] \textbf{Libreria}. UNISIM viene fornito con una libreria di componenti e di modelli completi. Questa libreria è aperta e ciascuno vi può caricare i propri moduli in modo da nutrire una più ampia attività di ricerca.
	\item[$\circ$] \textbf{Capacità}. UNISIM permette di aggiungere dei meccanismi di controllo in ciascun modulo in modo da implementare il power modeling, l'estrazione di statistiche, il campionamento, ecc\ldots
\end{itemize}
Vediamo ora di illustrare più dettagliatamente come le caratteristiche sopra elencate vengono implementate nel simulatore. 

\subsection{Dal diagramma a blocchi al modello di simulazione}
L'approccio strutturale prevede la mappattura di ogni blocco hardware (reale) in un modulo del simulatore. In questo modo, come già enfatizzato, è possibile riusare o sostituire parti del progetto minimizzando sforzo e costi. Si supponga, ad esempio, di voler realizzare un simulatore per l'architettura DLX\footnote{DLX è un'architettura di microprocessori RISC sviluppata da John L. Hennessy e David A. Patterson, i principali sviluppatori dell'architettura MIPS e del progetto Berkeley RISC i due progetti che diedero via all'epoca RISC. L'architettura DXL è sostanzialmente una versione semplificata e ripulita dell'architettura MIPS sviluppata per scopo didattico in ambito universitario.} riportata in Figura~\ref{fig:DLX-block-diagram}.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width = 13.5cm]{figure/DLX1}
	\caption{Schema a blocchi dell'architettura DLX.}
	\label{fig:DLX-block-diagram}
\end{figure}
Nel diagramma a blocchi sono presenti diversi componenti tra cui: la \textbf{Instruction Memory}, il \textbf{Register File}, una \textbf{ALU} per il calcolo degli indirizzi di memoria, di salto condizionato, di operazioni logico/aritmetiche e la \textbf{Data Memory}; il tutto inserito all'interno di una pipeline a cinque stadi. A ogniuno di questi blocchi corrisponderà un modulo del simulatore collegato agli altri in modo quasi identico a come avviene nel modello fisico.

\subsection{Astrazione del controllo}
Una parte significativa del codice del simulatore è associata al \textbf{controllo}. Poichè, generalmente, questo è centralizzato e dipende dall'architettura target, non è possile riutilizzarlo in altri progetti. Ciò rappresenta un problema poiché limita i benefici derivanti dall'utilizzo del modello di simulazione strutturale. UNISIM supera tale limitazione distribuendo il controllo tra i vari moduli del simulatore. 
In questo modo, ogni modulo esplicita come deve avvenire la comunicazione con gli altri ai quali è connesso. Se un modulo viene modificato, rimosso o aggiunto, solo la parte relativa al controllo viene influenzata. Inoltre, per consentire un migliore riutilizzo, si dovrebbe separare la parte di codice relativa al controllo da quella del blocco hardware. Il nuovo diagramma a blocchi appare come in Figura~\ref{fig:DLX-block-diagram2}.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width = 13.5cm]{figure/DLX2}
	\caption{Schema a blocchi dell'architettura DLX con il controllo distribuito.}
	\label{fig:DLX-block-diagram2}
\end{figure}
I riquari tratteggiati in grigio corrispondono ai moduli del simulatore.\\
Da quanto appena visto si evince come la realizzazione del simulatore, corrispondente a un diagramma a blocchi, richieda solamente tre passi:
\begin{itemize}
	\item[$\circ$] Costruzione di un modulo per ogni blocco hardware sopra menzionato (Memoria, Register File, ALU, ecc\ldots) e in modo più esplicito, definizione del loro comportamento interno.
	\item[$\circ$] Connessione dei vari moduli.
	\item[$\circ$] Definizione, all'interno di ogni modulo, di quando e come questo devrebbe reagire a dati in arrivo e quando e come dovrebbe elaborare i dati in uscita. 
\end{itemize}

\subsection{Definizione di un modulo}
I moduli sono definiti all'interno di un file avente estensione \texttt{.sim}, mediante una sintassi che estende quella del C++. Di seguito è riportato un esempio per la Instruction Memory della pipeline DLX:

\begin{lstlisting}[caption=Definizione di un modulo in UNISIM.,label=lst:listato1]
class InstructionMemory : public module
{
}
\end{lstlisting}
In Figura~\ref{fig:module1} è mostrata una rappresentazione grafica dello stesso modulo.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/module1}
	\caption{Rappresentazione grafica del blocco del simulatore.}
	\label{fig:module1}
\end{figure}

\subsection{Definizione comportamentale di un modulo}
Come si può vedere in Figura~\ref{fig:module1}, il modulo è descritto mediante un insieme di elementi. In particolare, sono presenti delle porte, che permettono la comunicazione con l'esterno, uno stato interno e un processo (o più processi in generale). Il processo definisce le azioni che vengono compiute sui dati che modellano lo stato. Il comportamento è esplicitato tramite un metodo C++ nel codice.
\begin{lstlisting}[caption=Definizione comportamentale del modulo.,label=lst:listato2]
class InstructionMemory : public module
{
	uint32_t mem[65536];
	uint32_t pc;
	uint32_t instr;
	
	void fetch()
	{
		instr = mem[pc];
	}
}
\end{lstlisting}
Nel listato precedente, si può notare come il modulo sia effettivamente una classe C++ mentre il processo, che in questo caso è rappresentato dall'operazione di caricameto di una istruzione dalla memoria, sia un metodo C++ che accede agli attributi della classe, che ne definiscono lo stato interno.

\subsection{Interfacciamento dei moduli: le \emph{porte}}
I moduli comunicano tra di loro mediante interfacce standardizzate che prendono il nome di \emph{porte}. Ciascun modulo può avere porte di ingresso e di uscita. Un ingresso è collegato con l'uscita tramite l'ausilio di segnali. Il passaggio di dati tra moduli avviene tramite scritture/letture su/da porte di ingresso/uscita. Poiché le connessioni tra le porte sono dichiarate separatamente dai moduli stessi, il cambiamento nel contenuto di un modulo non ha impatto sugli altri; nella maggior parte dei casi questo richiede solamente la ridefinizione delle connessioni.
\begin{lstlisting}[caption=Definizione delle porte.,label=lst:listato3]
inport <type> portname;  // definisce una porta dalla quale leggere
outport <type> portname; // definisce una porta sulla quale scrivere
\end{lstlisting}
Le parole chiave \texttt{inport} e \texttt{outport} specificano se la porta viene usata per ricevere o inviare dati. Le operazioni di scrittura e lettura da una porta adottano la seguente sintassi:
\begin{lstlisting}[caption=Lettura e scrittura su una porta.,label=lst:listato4]
foo = portname.data;  // legge il valore foo dalla porta di ingresso portname
portname.data = bar;  // scrive il valore di bar sulla porta di uscita portname
\end{lstlisting}
Mettendo insieme gli elementi raccolti finora e considerando il caso pratico della memoria istruzioni precedente, si ha:
\begin{lstlisting}[caption=Esempio di modulo InstructionMemory che fa uso di porte.,label=lst:listato4]
class InstructionMemory : public module
{
	uint32_t mem[65536];
	
	inport <uint32_t> pc_port;
	outport <uint32_t> instr_port;
		
	void fetch()
	{
		instr_port.data = mem[pc_port.data];
	}
}
\end{lstlisting}

\subsection{Segnali e sensitivity list}
Un modulo può avere diversi processi e un certo numero di porte di ingresso e di uscita. I processi devono poter essere attivati e per far questo bisogna definirne la sensitivity list. Questa è la principale differenza tra un metodo C++ e un processo. La sensitivity list contiene la lista di segnali di ingresso ai quali il modulo risponde attivando il giusto processo.

\begin{lstlisting}[caption=Sensitivity list.,label=lst:listato5]
sensitive_method(process_name) << port_name.signal_name;
\end{lstlisting}

Il codice precedente specifica che quando un nuovo valore viene scritto sul segnale \texttt{signal\_name}, connesso alla porta \texttt{port\_name}, allora il processo \texttt{process\_name} deve essere attivato. Naturalmente un processo può essere sensibile a più segnali e più segnali possono apparire nella sensitivity list di più processi. 
E' importante sottolineare che non può essere fatta nessuna assunzione relativa all'ordine con cui i processi vengono risvegliati se le dipendenze tra i segnali, implementate implicitamente nel simulatore, non specificano alcun ordine. Questo è simile all'elaborazione parallela che si ha all'interno di una architettura reale. Tale proprietà migliora il riuso e l'interoperabilità. 
C'è da considerare anche un altro aspetto. In teoria un processo che è sensibile a più segnali deve essere risvegliato ogni volta che uno di questi cambia; così, se più segnali cambiano all'interno dello stesso ciclo il processo viene invocato più volte; SystemC funziona in questo modo. Come risultato, chi scrive il codice deve tenere conto di questa evenienza; ad esempio, sarà necessario del codice aggiuntivo per evitare che a un'uscita venga assegnato un valore più volte nello stesso ciclo. Questo complica la codifica dei processi. UNISIM, invece, è progettato in modo che ogni segnale di uscita non possa essere cambiato due volte nello stesso ciclo, riducendo così in modo considerevole gli sforzi necessari alla codifica. Questa proprietà è chiamata \emph{monotonicità}.\\
La sensisitivity list è definita all'interno del costruttore della classe, per la Instruction Memory dell'esempio, si ha:
\begin{lstlisting}[caption=Esempio di modulo InstructionMemory con sensitivity list.,label=lst:listato6]
class InstructionMemory : public module
{	uint32_t mem[65536];
	inport <uint32_t> pc_port;
	outport <uint32_t> instr_port;
	
	InstructionMemory()
	{	sensitive_method(fetch) << pc_port.data;
	}
	
	void fetch()
	{	instr_port.data = mem[pc_port.data];
	}
}
\end{lstlisting}
La Figura~\ref{fig:module2} illustra i vari passi che portano all'attivazione di un processo, partendo dall'arrivo del segnale in ingresso alla generazione dell'uscita.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/module2}
	\caption{Passi di attivazione del processo all'interno del modulo.}
	\label{fig:module2}
\end{figure}

\subsection{Il segnale \emph{clock}}
Il clock, di fatto, è implementato come qualsiasi altro segnale di ingresso, ma poiché ha un ruolo particolare è definito attraverso una speciale parola chiave.
\begin{lstlisting}[caption=Definizione del segnale di clock.,label=lst:listato7]
inclock clock_name;
\end{lstlisting}
L'utente è libero di definire processi sensibili al clock (sequenziali) o insensibili (combinatori). Ad ogni modo, egli deve distinguere tra fronte di clock ascendente e discendente.
\begin{lstlisting}[caption=Fronti di clock ascendenti e discendenti.,label=lst:listato8]
sensitive_pos_method(processname) << clockname;
sensitive_neg_method(processname) << clockname;
\end{lstlisting}
Il motore di simulazione tratta i processi in un certo ordine a seconda del fatto che questi siano sensibili al fronte positivo di clock, al fronte negativo o ad altri segnali. All'interno di un ciclo di clock il simulatore prima risveglia i processi sensibili ai fronti di clock positivi, in ordine non definito, poi risveglia quelli sensibili ai segnali diversi da quello di clock e infine, risveglia i processi sensibili ai fronti di clock negativi. 
Questa convenzione permette al programmatore di modellare in modo semplice latch in ingresso a un blocco hardware.

\subsection{Assemblaggio del simulatore}
Una volta definiti i moduli e il loro comportamento interno, si passa all'assemblaggio del simulatore. Per ogni componente bisogna specificare quante copie sono presenti e come sono connesse tra loro. Questa descrizione è contenuta in un differente tipo di file, avente estensione \texttt{.uni}.

\subsubsection{Istanza di un modulo}
Proprio come una classe C++ anche un modulo ha bisogno di essere istanziato. Le istanze sono definite all'interno di un file \texttt{.uni} usando la sintassi:
\begin{lstlisting}[caption=Istanza di un modulo.,label=lst:listato9]
instance  MyModule1 m1;
instance  MyModule2 m2;
\end{lstlisting}
La prima istruzione crea un'istanza del modulo \texttt{MyModule1} chiamata \texttt{m1}. Come si può notare questa è, ancora una volta, una dichiarazione in stile C++ con la parola chiave \texttt{instance} in testa. Nella precedente striscia di codice le definizioni dei moduli MyModule1 e MyModule2 non sono presenti e vanno perciò aggiunte:
\begin{lstlisting}[caption=Inclusione della definizione del modulo.,label=lst:listato10]
#include "mymodule1.sim"
#include "mymodule2.sim"

instance MyModule1 m1;
instance MyModule2 m2;
\end{lstlisting}

\subsubsection{Connessione dei moduli}
L'ultima cosa che resta da fare per completare il simulatore è quella di collegare tra loro tutti i blocchi; questo viene fatto attraverso le porte. Considerando i due moduli del Listato~\ref{lst:listato9} e supponendo che il \texttt{mymodule1} abbia una porta \texttt{port1} che va collegata alla porta \texttt{port2} di \texttt{mymodule2} allora, all'interno del file \texttt{.uni} tale connessione sarà esplicitata come:
\begin{lstlisting}[caption=Connessione dei moduli.,label=lst:listato11]
#include "mymodule1.sim"
#include "mymodule2.sim"

instance MyModule1 m1;
instance MyModule2 m2;

m1.port1 >> m2.port2;
\end{lstlisting}

\subsection{Modellazione di comportamenti complessi}
Con UNISIM è anche possibile implementare situazioni di controllo più complesso in maniera distribuita.

\subsubsection{Introduzione al segnale \texttt{nothing}}
Un processo può essere sensibile a un certo numero di segnali di ingresso, nonostante ciò i processi che generano tali segnali non devono per forza essere attivi a ogni ciclo, così il loro valore può non essere definito. Il valore "undefined" non ha significato dal punto di vista hardware (i fili devono sempre avere un valore assegnato). In modo simile i segnali doveno avere un valore o riportarne uno speciale detto \emph{nothing}. Questo aiuta a prevenire, nel simulatore, comportamenti inaspettati dovuti a bug introdotti dalla sostituzione di un modulo o dal suo riuso. 
Per illustrare l'utilizzo di tale valore, si consideri ancora una volta la pipeline dell'architettura DLX in Figura~\ref{fig:DLX-block-diagram}. Si focalizzi l'attenzione sulle istruzioni di brach. Poiché l'indirizzo del branch viene calcolato dalla ALU nella pipeline, altre due istruzioni possono essere caricate prima che il branch sia eseguito. Supponendo di non voler supportare lo svuotamento della pipeline, si rende necessaria l'introduzione di due bubble dopo ogni istruzione di branch. Questo viene fatto, nel simulatore, tramite l'uso del valore \texttt{nothing}, che viene mandato in uscita dalla porta \texttt{instr\_port} della memoria istruzioni per due cicli consecutivi, come di seguito indicato:
\begin{lstlisting}[caption=Utilizzo del valore \texttt{nothing}.,label=lst:listato12]
class InstructionMemory : public module
{	outport <uint32_t} instr_port;
	...
	
	void process()
	{
		...
		if(...)
		{	//C'è bisogno di un bubble nella pipeline
			instr_port.data.nothing();
		}
		...
	}
}
\end{lstlisting}
E' possibile verificare se un segnale ha o meno valore \texttt{nothing} usando il metodo \texttt{something()}, come nell'esempio seguente, dove viene considerato il caso di Register File:
\begin{lstlisting}[caption=Verifica del valore \texttt{nothing} tramite metodo \texttt{something()}.,label=lst:listato13]
class RegisterFile : public module
{	inport instr;
	outport operand1;
	outport operand2;
	...
	
	void read()
	{
		if(instr.data.something())
		{	int rs1_index = get_rs1(instr.data);
			int rs2_index = get_rs2(instr.data);
			operand1.data = regs[rs1_index];
			operand2.data = regs[rs2_index];
		}
		else
		{	operand1.data.nothing();
			operand2.data.nothing();
		}
	}
	...
}
\end{lstlisting}
Nell'esempio, il Register File controlla se i suoi ingressi sono settati al valore \texttt{nothing}. Se non lo sono, invia i corrispondenti operandi alla ALU. Se invece sono \texttt{nothing}, inoltra alla ALU tale valore.  

\subsubsection{I segnali di stato \texttt{known/unknown}}
Come detto precedentemente, i processi sono risvegliati ogni qual volta viene settato un nuovo valore per i segnali ai quali sono sensibili. Questi segnali vengono ricevuti, a ogni ciclo di clock, in un ordine non determinato. Perciò, in aggiunta al valore viene definito anche uno stato. Questo è usato per sapere se un segnale è stato settato o no durante il corrente ciclo di clock. All'inizio di ogni ciclo il simulatore reimposta tutti i segnali allo stato \texttt{unknown}; ogni qualvolta viene settato un nuovo valore (incluso il valore \texttt{nothing}), lo stato viene impostato a \texttt{known}. Si consideri, a titolo di esempio, il processo \texttt{compute} di un modulo ALU a due ingressi. I segnali di ingresso sono \texttt{val1} e \texttt{val2}. Solo quando entrambi sono \texttt{known} l'uscita può essere calcolata. 
\begin{lstlisting}[caption=Stato dei segnali:\texttt{known/unknown}.,label=lst:listato14]
class RegisterFile : public module
{	inport <uint32_t> val1;
	inport <uint32_t> val2;
	outport <uint32_t> result;
	
	...
	
	void compute()
	{
		if(val1.data.known() && val2.data.known())
		{
			if(val1.data.something() && val2.data.something())
			{	//Calcola il risultato per i precendenti ingressi
				...
			}
		}
		...
	}
}
\end{lstlisting}

\subsubsection{Il segnale \texttt{accept}}
Finora si è sempre assunto che il processo potesse mandare i dati al target al quale è connesso. Comunque, in molti casi, questo non è possibile (ad esempio nel caso di un buffer pieno). Una soluzione semplice è quella di controllare lo stato del target prima di inviare i dati. Per fare questo viene definito il segnale \texttt{accept}. In reatà ci sarebbe bisogno di tre segnali aggiuntivi: uno di richiesta dello stato, uno di risposta e uno per l'invio del dato. Nella pratica il primo può essere eliminato inviando direttamente il dato, tramite il segnale \texttt{data} e aspettando la notifica, da parte del target, di avvenuta ricezione. La Figura~\ref{fig:module3} mostra come il segnale \texttt{accept} viene usato per disaccoppiare due moduli. Le frecce rosse rappresentano il segnale \texttt{data} e le blu il segnale \texttt{accept}.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/module3}
	\caption{Impiego del segnale \texttt{accept}.}
	\label{fig:module3}
\end{figure}
Il codice corrispondente al Register File diviene dunque:
\begin{lstlisting}[caption=Impego del segnale \texttt{accept}.,label=lst:listato15]
class RegisterFile : public module
{	inport <uint32_t> instr;
	outport <uint32_t> operand1;
	outport <uint32_t> operand2;
	...

	void read()
	{	int rs1_index = get_rs1(instr.data);
		int rs2_index = get_rs2(instr.data);
		//Send the operands unconditionally
		operand1.data = regs[rs1_index];
		operand2.data = regs[rs2_index];
	}

	void on_accept()
	{	// Process called upon receiving accepts from ALU.
		if(operand1.accept.known() && operand2.accept.known())
		{ 
			if(operand1.accept && operand2.accept)
			{ 	//Received accepts from ALU, can consider
				//next instruction received from the fetch,
				//replacing current instruction.
				instr.accept = true;
			}
			else
			{ 	//Received accepts from ALU, can't consider
				//next instruction received from the fetch.
				instr.accept = false;
			}
		}
	}
	
	...
}
\end{lstlisting}
In questo modo, se il Register File è occupato invia \texttt{false} sul segnale \texttt{accept} prima di ricevere ulteriori richieste dalla Instruction Memory. In caso contrario, manda \texttt{true}.

\subsubsection{Il segnale \texttt{enable}}
Ora che il modulo ha il segnale \texttt{accept} può reagire nel modo corretto se ha mandato un dato a un target che non poteva riceverlo perché occupato. Ma cosa succede se il modulo ha diverse uscite? Evidentemente, alcune di queste potranno rispondere con un \texttt{accept} e altre con un \texttt{non-accept}. 
Si consideri ora la seguente situazione. Si supponga che il DLX sia in grado di trattare istruzioni VLIW, composte da due parti. E' presente un unico Register File capace di elaborare le richieste e due ALU distinte che si occupano ciascuna di una parte dell'istruzione. Le connessioni sono mostrate in Figura~\ref{fig:module4}.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/module4}
	\caption{Due ALU collegate a un Register File VLIW.}
	\label{fig:module4}
\end{figure}
Le due parti dell'istruzione devono essere elaborate allo stesso tempo; così, una ALU non dovrebbe partire prima che anche l'altra abbia dato il segnale di \texttt{accept} alto. Per implementare tale comportamento senza connettere tra loro le ALU, si ha bisogno che il Register File abiliti entrambe al calcolo. Questo viene fatto tramite il segnale di \texttt{enable}. Le ALU non possono passare al calcolo dell'uscita, una volta dato l'\texttt{accept} al Register File, finché quest ultimo non ha risposto con il segnale di \texttt{enable} alto per entrambe. La connessione tra il Register File e le ALU, aggiungendo il segnale di \texttt{enable}, è riportata in Figura~\ref{fig:module5}. 
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/module5}
	\caption{Due ALU collegate a un Register File VLIW con il segnale \texttt{enable}.}
	\label{fig:module5}
\end{figure} 

\begin{lstlisting}[caption=Processo \texttt{on\_accept}.,label=lst:listato16]
on_accept()
{ 
	if (out1.accept.known() && out2.accept.known())
	{
		if(out1.accept && out2.accept)
		{ 
			out1.enable = true;
			out2.enable = true;
		}
		else
		{ 
			out1.enable = false;
			out2.enable = false;
		}
	}
}
\end{lstlisting}
Proprio come tutti gli altri segnali, anche quelli di \texttt{accept} e \texttt{enable} possono essere \texttt{true}, \texttt{false} o \texttt{unknown} e apparire nelle sensitivity list dei processi. 

\section{Cellsim}
Cellsim è un simulatore per architetture multiprocessore di tipo eterogeneo\cite{cellsim-journal}. L'infrastruttura di supporto adottata per la descrizione dei moduli del simulatore e la loro connessione è UNISIM; il quale è stato introdotto nel paragrafo precedente. 
Attualmente Cellsim implementa l'architettura corrispondente alla prima versione del processore Cell (la CBEA). Il simulatore è configurato in modo tale da fornire un banco di prova da contrapporre al processore reale. 
Ciascuno dei moduli del simulatore, come mostrato in Figura~\ref{fig:Cellsim-block-diagram}, rappresenta un blocco hardware del processore in Figura~\ref{fig:CBEA-block-diagram2}. 
\begin{figure}[!htbp]
	\centering
	\subfigure[\label{fig:CBEA-block-diagram2}]{\includegraphics[scale = 0.8]{figure/CBEA3}}
	\subfigure[\label{fig:Cellsim-block-diagram}]{\includegraphics[scale = 0.8]{figure/Cellsim}}
	\caption{Diagramma a blocchi della CBEA (Figura~\ref{fig:CBEA-block-diagram2}) e diagramma a blocchi del simulatore Cellsim ((Figura~\ref{fig:Cellsim-block-diagram}).}
	\label{fig:CBEA-Cellsim}
\end{figure} 
Tali blocchi sono: PPU, Cache, SPU, MFC, Memory e rete di interconnessione (k-bus). Tramite quest'ultima, è possibile collegare una PPE, 8 SPE e un modulo di memoria; ottenendo così la stessa configurazione hardware del sistema reale. Comunque è anche possibile collegare più PPE e SPE, mantenendo però i limiti dovuti alla rete di interconnessione.

\subsection{La classe MemoryAccess}
La classe MemoryAccess è lo strumento usato da Cellsim per fornire un'interfaccia di comunicazione comune a tutti i moduli del simulatore. La definizione della classe è la seguente:
\begin{lstlisting}[caption=La classe MemoryAccess.,label=lst:listato17]
class MemoryAccess
{
	int			_type;
	address_t	_target;
	address_t	_source;
	size_t		_size;
	uint8_t*	_data;
}
\end{lstlisting}
Quando un modulo deve iniziare una transazione con un altro, crea un'istanza di MemoryAccess nella quale va a settare i vari campi:
\begin{itemize}
	\item[$\circ$] \texttt{\_type}: rappresenta il tipo di accesso. Sono possibili i seguenti tipi di transazione: load (\_type = 1), store (\_type = 2), atomic\_load (\_type = 3), atomic\_store (\_type = 4). Queste ultime due vengono utilizzate per monitorare le locazioni di memoria centrale caricate nella cache del processore e implementare lo snooping\footnote{L'algoritmo di snoopig fornisce un meccanismo per il controllo della cache coherency. Ogni volta che la cache carica delle pagine dalla memoria centrale utilizza una atomic\_load, se un altro processore effettua delle modifiche su tali locazioni, l'algoritmo segnala alla cache il fatto invalidandone il contenuto.}.
	\item[$\circ$] \texttt{\_target}: contiene l'indirizzo fisico (memory mapped) del blocco destinatario della transazione. 
	\item[$\circ$] \texttt{\_source}: contiene l'indizzo fisico del modulo che inizia la transazione. 
	\item[$\circ$] \texttt{\_size}: indica la dimensione, in byte, del trasferimento.
	\item[$\circ$] \texttt{\_data}: contiene un puntatore alla locazione di memoria nella quale è contenuto il primo byte componente il dato oggetto del trasferimento.
\end{itemize}
Questa interfaccia comune, combinata al fatto che ogni modulo ha un range fisico di pagine assegnate, fornisce la necessaria flessibilità per avere un simulatore modulare. 

\subsection{La Memoria}
Il modulo di memoria (Figura~\ref{fig:memory}) è utilizzato sia per la memoria principale che per le LS. Questo non implementa nessuna distribuzione specifica dei banchi interni; in questo modo gli accessi sequenziali si possono sovrapporre. Ad ogni modo, la latenza e il numero di porte di accesso possono essere configurati. Perciò, tale modulo può essere utilizzato anche dalle SPE per implementare le LS, le quali hanno diverse porte collegate sia alla SPU che al MFC.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.5]{figure/Memory}
	\caption{Blocchi di memoria}
	\label{fig:memory}
\end{figure}

\subsection{La PPE}
La PPE (Figura~\ref{fig:PPE-diagram}) è composta da due moduli, PPU e Cache. La PPU è un PowerPC 405 32-bit capace di eseguire un certo numero di istruzioni per ciclo di simulazione; le istruzioni di load/store e il fecthing in generale, vengono richieste tramite connessione alla Cache.
Il modulo PPU è un instruction set simulator (ISS) con una banda di caricamento parametrizzabile e single-threaded.  La PPE non emula completamente il sistema reale; la PPU è responsabile dell'emulazione dei servizi del sistema operativo, come: caricamento ed esecuzione dei file elf, chiamate di sistema, start e stop delle SPE, mappatura degli indirizzi logici in quelli fisici, ecc\ldots
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.5]{figure/PPE-diagram}
	\caption{Schema a blocchi della PPE}
	\label{fig:PPE-diagram}
\end{figure}

\subsection{La SPE}
La SPE (Figura~\ref{fig:SPE-diagram}) è composta da tre moduli: SPU, LS e MFC. La SPU è un simulatore funzionale capace di eseguire un certo numero di istruzioni per ciclo di sistema. Questo modulo ha due connessioni con la LS, uno per l'instruction fetch e l'altro per le operazioni di Load e Store. L'accesso al canale trasmissivo è ottenuto tramite una delle connessioni con MFC, mentre l'altra è impiegata per riportare lo stato della SPU e per lo start e stop della stessa da parte della PPU, usando dei registri memory mapped. La LS soddisfa le richieste di Load e Store da parte della SPU e del MFC. Tutti i comandi DMA legati ai servizi di trasferimento dati sono gestiti proprio da quest'ultima; inoltre questa contiene dei registri memory mapped per la SPE.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.5]{figure/SPE-diagram}
	\caption{Schema a blocchi della SPE}
	\label{fig:SPE-diagram}
\end{figure}

\subsection{Rete di interconnessione}
L'Element Interconnect Bus (EIB) del Cell è uno strumento di interconnessione molto efficente, comunque non è scalabile. Per questo motivo Cellsim implementa la rete di interconnessione tramite una topologia k-bus. Benché questa sia significativamente differente da EIB, si è dimostrata capace di fornire la necessaria flessibilità e opportunamente configurata, di raggiungere prestazioni simili a quelle del sistema reale. Il mezzo di interconnessione implementa inoltre un algoritmo di snooping per la gestione della cache coherency. 
I moduli connessi all'infrastruttura di comunicazione sono mappati in uno spazio di indirizzamento globale e sono connessi a questa tramite due porte, una di ingresso e una di uscita, in modo da poter inviare e ricevere pacchetti MemoryAccess. Questi pacchetti sono inoltrati nella rete usando una tabella di routing (Tabella~\ref{tab:routing-table}). Con tale configurazione è possibile connettere alla rete una memoria (fino a 1GB di dimensione), un numero arbitrario di PPE (fino a 4096) e di SPE (fino a 112).
\begin{table}[ht]
	\centering
	\begin{tabular}{|c|c|c|}
	\hline Physical page range & Module & IN Port \\ 
	\hline [0x0000 - 0x4000) & Memory & 0  \\ 
	\hline [0x4000 - 0x4100) & LS0 & NUM\_PPEs + 1\\ 
	\hline [0x4100 - 0x4200) & LS1 & NUM\_PPEs + 2\\
	\hline ... & ... & ... \\ 
	\hline [0xB000 - 0xB001) & PPE0 & 1\\
	\hline [0xB001 - 0xB002) & PPE1 & 2\\ 
	\hline ... & ... & ... \\ 
	\hline [0xC000 - 0xC001) & MFC0 & NUM\_PPEs + 1\\ 
	\hline [0xC001 - 0xC002) & MFC1 & NUM\_PPEs + 2\\ 
	\hline ... & ... & ... \\ 
	\hline 
	\end{tabular}
	\caption{Routing table per la rete di interconnessione}
	\label{tab:routing-table} 
\end{table}
Nella Tabella~\ref{tab:configuration-parameters} sono riportati i parametri di configurazione del simulatore, confrontati con quelli del sistema reale.
\begin{table}
\centering
\begin{tabular}{|c|c|c|c|}
\hline & Parameter & Cell & CS \\ 
\hline 
\hline
\multicolumn{4}{|c|}{PPE}\\
\hline PPU & Issue Bandwidth & 2 $\times$ th & 1 \\ 
\hline Cache & Numbero of lines & 512 & 512 \\ 
			 & Line size & 128 & 128 \\ 
        	 & Number of ways & 8 & 8 \\ 
\hline 
\hline
\multicolumn{4}{|c|}{SPE}\\
\hline SPU & Issue Bandwidth & 2 & 2 \\
\hline LS & Size (KB) & 256 & 256 \\
	      & Latency (cycles) & 6 & 6 \\
	      & Number of ports & 1 & 3 \\
\hline MFC & DMA cmd queue size & 16 & 16 \\
 	       & DMA cmd processing & & \\
	       & Delay (cycles) & ... & 30 \\
\hline

\hline EIB & \# of ring/buses & 4 & 3-4-5 \\
 	       & BW (B/cycles) & 8 & 8 \\
	       & Number of outstanding & & \\
		   & transfers/node & 16 & 16 \\
\hline
\end{tabular}
\caption{Confronto tra la configurazione Cell e quella Cellsim (CS)}
\label{tab:configuration-parameters}
\end{table} 

\subsection{Protocollo di comunicazione}
I moduli del simulatore si scambiano informazioni sottoforma di pacchetti, modellati tramite la classe MemoryAccess. Come già visto, questa contiene tutte le informazioni necessarie al bus per inoltrare il pacchetto verso la corretta destinazione. Lo scambio dei MemoryAccess avviene per mezzo di un opportuno protocollo di comunicazione di seguito descritto. \\
Tutti i moduli del simulatore contengono al loro interno dei processi di base mediante i quali viene gestita la sincronizzazione. I processi in questione sono:
\begin{itemize}
	\item[$\circ$] \texttt{start\_of\_cycle()}: sensibile ai fronti positivi del clock.
	\item[$\circ$] \texttt{end\_of\_cycle()}: sensibile ai fronti negativi del clock.
	\item[$\circ$] \texttt{on\_accept()}: sensibile al segnale accept.
	\item[$\circ$] \texttt{on\_data()}: sensibile al segnale data.
\end{itemize}  
Ogni qualvolta due moduli devono scambiarsi un pacchetto, eseguono la seguente procedura:
\begin{enumerate}
	\item \texttt{start\_of\_cycle()}: il modulo mittente invia al destinatario il MemoryAccess tramite il segnale \texttt{data};
	\item \texttt{on\_data()}: il modulo ricevente registra la variazione del segnale \texttt{data}, sulla porta di ingresso e attiva il processo che esegue un controllo sull'input buffer per verificare la disponibilità di uno slot. In caso affermativo risponde al mittente con un segnale di \texttt{accept} alto;
	\item \texttt{on\_accept()}: il modulo mittente riceve il segnale di \texttt{accept} alto e invia, come risposta, un segnale di \texttt{enable} alto;
	\item \texttt{end\_of\_cycle()}: a questo punto, il dato in ingresso è valido e il destinatario può utilizzarlo per l'elaborazione.
\end{enumerate}
In Figura~\ref{fig:com-protocol} è riportata un rappresentazione grafica della la procedura sopra descritta, nel caso di comunicazione processore-memoria.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale = 0.7]{figure/comunication-protocol}
	\caption{Protocollo di comunicazione adottato in Cellsim.}
	\label{fig:com-protocol}
\end{figure}
Il codice corrispondente all'esempio è riportato di seguito.
\begin{lstlisting}[caption=Processor.sim,label=lst:listato18]
class Processor: public module
{	inport <int> in;
	outport <int> out;
	int my_foo;
	
	Processor(): module(){}
	void start_of_cycle()
	{	out.data = my_foo;
	}

	void on_accept()
	{	out.enable = out.accept;
	}
	
	void end_of_cycle(){}
\end{lstlisting}
\begin{lstlisting}[caption=Memory.sim,label=lst:listato19]
class Memory: public module
{	inport <int> in;
	outport <int> out;
	int my_data;
	
	Memory(): module(){}
	void start_of_cycle(){}

	void on_data()
	{	in.accept = in.data.something();
	}
	
	void end_of_cycle()
	{	if(in.enable)
			my_data = in.data;
	}
\end{lstlisting}

\subsection{Gerarchia dei moduli del simulatore}
Le istanze dei moduli che compongono il simulatore, comprese le interconnessioni tra le varie porte, sono definite all'interno del file \texttt{cellsim.uni}. I moduli del simulatore sono descritti dai seguenti file:
\begin{enumerate}
	\item \texttt{Processor.sim}: contiene il codice per l'implementazione delle funzionalità di base del processore, mentre la gestione dei thread viene ottenuta tramite codice integrativo all'interno del file \texttt{ProcessorThread.h}.
	\item \texttt{Cache.sim}: implementa un semplice blocco di memoria cache, comprese le funzionalità di \emph{write through} e \emph{invalidate}. 
	\item \texttt{spu.sim}: è il modulo contenente l'implementazione della SPU.
	\item \texttt{mfc.sim}: rappresenta il memory flow controller della SPE, utilizzato per l'esecuzione dei comandi DMA.
	\item \texttt{ls.sim}: è il modulo che si occupa dell'implementazione della local store presente nelle SPE.
	\item \texttt{EIB.sim}: è l'infrastruttura di comunicazione utilizzata nel simulatore per il trasferimento dei memory access e per la gestione della cache coherency.
	\item \texttt{Memory\_multiport.sim}: è il modulo di memoria centrale.
	\item \texttt{default\_configuration\_parameters.h}: è il file di configurazione contenente tutti i parametri del simulatore, come ad esempio il numero di PPE e SPE, la dimensione della memoria, le informazioni sulla latenza, ecc\ldots 
\end{enumerate}
Tra i file sopra citati, quelli relativi alla PPE sono contenuti all'interno del path \texttt{./cellsim-0.9/src/modules/processor}, mentre quelli relativi alla SPE sono contenuti in \texttt{./cellsim-0.9/src/modules/accelerator}. Il file di configurazione è, insieme a quello delle istanze \texttt{cellsim.uni}, situato nel percorso \texttt{./cellsim-0.9/src/}\-\texttt{modules}. Per quanto riguarda invece l'interfaccia di comunicazione \texttt{MemoryAccess}, il file corrispondente (\texttt{MemoryAccess.h}) è contenuto in \texttt{./cellsim-0.9/src/library/}\-\texttt{simulator}.
\begin{figure}[!htbp]
	\centering
	\subfigure[\label{fig:gerarchia-sim}]{\includegraphics[width = 7cm]{figure/gerarchia-sim}}\qquad
	\subfigure[\label{fig:gerarchia-cartelle}]{\includegraphics[width = 7cm]{figure/gerarchia-cartelle}}
	\caption{In Figura~\ref{fig:gerarchia-sim} è riportata la gerarchia dei file del simulatore; e in  Figura~\ref{fig:gerarchia-cartelle} è riportata l'organizzazione gerarchica delle cartelle.}
	\label{fig:gerarchie}
\end{figure}

%\subsection{Compilare e simulare un'applicazione}
%Le applicazioni di test sono contenute nella cartella \texttt{native}. Per eseguirne una è necessario compiere i seguenti passi:
%\begin{enumerate}
%	\item \textbf{Generazione del file cellsim.uni.cxx}. Tale file viene prodotto dall'UNISIM-compiler prendendo come ingresso \texttt{cellsim.uni}. Il risultato è un top-module che viene poi utilizzato dal compilatore C++ per generare il binario \texttt{cellsim}, inserito nella cartella \texttt{bin} e necessario per il lancio della simulazione. 
%	\item \textbf{Compilazione dei sorgenti del progetto}. Per poter eseguire l'applicazione scelta bisogna prima compilarne i sorgenti, uno per la PPE e uno per la SPE\footnote{PPE e SPE hanno ISA differenti, perciò sono necessari due compilatori diversi.}
%	\item \textbf{Link simbolico dei binari}. A questo punto sono disponibili tre eseguibili. Uno per il simulatore e due per l'applicazione (PPE e SPE), più eventuali file di configurazione relativi all'applicazione stessa. Quando viene lanciata la simulazione, tramite il commando \texttt{./bin/cellsim} viene caricato il binario della PPE indirizzato attraverso il link simbolico \texttt{cell-test}. A sua volta il binario della PPE carica l'immagine della SPE, indirizzata tramite il link simbolico avente lo stesso nome. 
%\end{enumerate}
%In Figura~\ref{fig:compilatore} è illustrato graficamente il procedimento appena descritto.
%\begin{figure}[!htbp]
%	\centering
%	\includegraphics[scale = 0.7]{figure/Cellsim-compiler}
%	\caption{Compilazione di un nuovo progetto.}
%	\label{fig:compilatore}
%\end{figure}